<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BiT-Flow ãƒ‡ãƒ¢ - ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ç‰ˆ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- MXGraph ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
    <script type="text/javascript">
        // MXGraphã®ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šï¼ˆ404ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
        window.mxLoadResources = false;  // ãƒªã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿ã‚’ç„¡åŠ¹åŒ–ï¼ˆ404ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
        window.mxBasePath = 'https://jgraph.github.io/mxgraph/javascript/src';
        window.mxLoadStylesheets = false;  // ã‚¹ã‚¿ã‚¤ãƒ«ã‚·ãƒ¼ãƒˆã®èª­ã¿è¾¼ã¿ã‚’ç„¡åŠ¹åŒ–ï¼ˆ404ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
        window.mxImageBasePath = 'https://jgraph.github.io/mxgraph/javascript/src/images';
        
        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã¯ç„¡åŠ¹åŒ–ï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°ã‚’æ¸›ã‚‰ã™ï¼‰
        window.mxDebug = false;
    </script>
    <script type="text/javascript" src="https://jgraph.github.io/mxgraph/javascript/mxClient.js"></script>
    <script type="text/javascript">
        // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ç¢ºèª
        window.addEventListener('load', function() {
            if (typeof mxGraph === 'undefined') {
                console.error('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
            } else {
                console.log('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿å®Œäº†:', typeof mxGraph);
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
            color: #2d3748;
            margin: 0;
        }

        .header {
            background: linear-gradient(135deg, #495057 0%, #343a40 100%);
            border-bottom: none;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.2),
                0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10;
        }

        .header-logo-link {
            position: absolute;
            left: 24px;
            text-decoration: none;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .header-logo {
            height: 40px;
            width: auto;
            opacity: 0.9;
            transition: all 0.3s ease;
        }

        .header-logo-link:hover .header-logo {
            opacity: 1;
            transform: scale(1.05);
        }

        .header h1 {
            color: #ffffff;
            font-size: 1.8em;
            margin: 0;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .demo-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 60px);
            max-width: 1800px;
            margin: 0 auto;
            overflow: hidden;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 0;
            overflow: hidden;
            height: 100%;
        }

        .chat-section {
            flex: 1;
            min-height: 0;
            height: 50%;
            overflow: hidden;
        }

        .code-section {
            flex: 1;
            min-height: 0;
            height: 50%;
            overflow: hidden;
        }

        .panel {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.15),
                0 12px 28px rgba(0, 0, 0, 0.12),
                0 4px 12px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .panel-header {
            background: linear-gradient(135deg, #495057 0%, #343a40 100%);
            color: white;
            padding: 12px 20px;
            font-weight: 500;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: none;
        }

        .panel-status {
            font-size: 0.8em;
            background: rgba(255,255,255,0.25);
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 400;
            backdrop-filter: blur(4px);
        }

        .panel-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            position: relative;
            background: #ffffff;
            color: #2d3748;
            min-height: 0;
            height: calc(100% - 45px);
        }

        /* å…¥åŠ›ãƒ‘ãƒãƒ« */
        #prompt-input {
            width: 100%;
            height: 120px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
        }

        #prompt-input:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.2);
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            position: relative;
            z-index: 10;
        }

        .btn-primary {
            background: linear-gradient(135deg, #495057 0%, #343a40 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .btn-primary:disabled {
            background: linear-gradient(135deg, #a0aec0 0%, #cbd5e0 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ‘ãƒãƒ« */
        #claude-response {
            white-space: pre-wrap;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.5;
            color: #333;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            min-height: 200px;
            overflow-y: auto;
        }

        /* drawioã‚³ãƒ¼ãƒ‰ãƒ‘ãƒãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒï¼‰ */
        #svg-code {
            white-space: pre;
            font-family: 'JetBrains Mono', 'Monaco', 'Menlo', 'Ubuntu Mono', Consolas, monospace;
            font-size: 12px;
            line-height: 1.6;
            color: #e2e8f0;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            overflow-y: auto;
            overflow-x: auto;
            height: 100%;
            min-height: 150px;
            max-height: 100%;
            tab-size: 2;
            text-align: left;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* drawioã‚³ãƒ¼ãƒ‰ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚¹ã‚¿ã‚¤ãƒ« */
        .svg-tag {
            color: #f92672;
            font-weight: bold;
        }

        .svg-attribute {
            color: #a6e22e;
        }

        .svg-value {
            color: #e6db74;
        }

        .svg-comment {
            color: #75715e;
            font-style: italic;
        }

        .svg-number {
            color: #ae81ff;
        }

        /* ãƒãƒ£ãƒƒãƒˆå½¢å¼ã®ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆãƒ¢ãƒ€ãƒ³ã‚·ãƒ³ãƒ—ãƒ«ãƒ»è¦–èªæ€§é‡è¦–ï¼‰ */
        .chat-message {
            margin-bottom: 12px;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            position: relative;
            font-size: 14px;
            line-height: 1.6;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.06);
        }

        .chat-message.user {
            background: linear-gradient(135deg, #fff5f5 0%, #fef3c7 100%);
            color: #2d3748;
            border-left: 3px solid #f59e0b;
            margin-left: auto;
            margin-right: 0;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.1);
        }

        .chat-message.assistant {
            background: #ffffff;
            border: 1px solid rgba(102, 126, 234, 0.15);
            color: #2d3748;
            margin-left: 0;
            margin-right: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .chat-message.system {
            background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
            color: #718096;
            border: 1px solid rgba(0, 0, 0, 0.05);
            margin: 0 auto;
            max-width: 85%;
            text-align: center;
            border-radius: 20px;
            font-style: italic;
        }

        .message-content {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 5px;
        }

        .message-time {
            font-size: 11px;
            color: #666;
            text-align: right;
            margin-top: 5px;
        }

        .chat-message.user .message-time {
            text-align: right;
        }

        .chat-message.assistant .message-time {
            text-align: left;
        }

        /* ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºãƒœã‚¿ãƒ³ã‚¹ã‚¿ã‚¤ãƒ« */
        .prompt-info-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.15);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #4b5563;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .prompt-info-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.15);
            transform: scale(1.1);
        }

        /* ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
        .prompt-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        .prompt-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .prompt-modal-content {
            background: white;
            border-radius: 12px;
            max-width: 800px;
            max-height: 80vh;
            width: 90%;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .prompt-modal-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .prompt-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }

        .prompt-modal-close {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            background: #f3f4f6;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .prompt-modal-close:hover {
            background: #e5e7eb;
        }

        .prompt-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .prompt-section {
            margin-bottom: 20px;
        }

        .prompt-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #6b7280;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .prompt-content {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.3;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #374151;
            max-height: 300px;
            overflow-y: auto;
        }

        .prompt-copy-btn {
            margin-top: 8px;
            padding: 6px 12px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .prompt-copy-btn:hover {
            background: #2563eb;
        }

        .prompt-copy-btn.copied {
            background: #10b981;
        }

        .typing-indicator {
            background: #f7f7f7;
            border-left: 4px solid #999;
            padding: 10px;
            border-radius: 5px 15px 15px 15px;
            font-style: italic;
            color: #666;
            margin-left: 0;
            margin-right: 20%;
        }

        .typing-dots {
            display: inline-block;
        }

        .typing-dots span {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #999;
            margin: 0 2px;
            animation: typing 1.4s infinite ease-in-out both;
        }

        .typing-dots span:nth-child(1) { animation-delay: -0.32s; }
        .typing-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes typing {
            0%, 80%, 100% { 
                transform: scale(0);
            } 40% { 
                transform: scale(1);
            }
        }

        /* ãƒ•ãƒ­ãƒ¼å›³ãƒ‘ãƒãƒ« */
        #flow-diagram {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã¡ã‚‰ã¤ãã‚’é˜²ã */
            background: #fafafa;
            min-height: 200px;
            width: 100%;
            height: 100%;
            position: relative;
            /* drawioãƒ•ãƒ©ãƒƒã‚·ãƒ¥é˜²æ­¢: åˆæœŸçŠ¶æ…‹ã§éè¡¨ç¤º */
            visibility: visible;
        }

        #flow-diagram svg {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            /* drawioã®åˆæœŸè¡¨ç¤ºè¨­å®š */
            display: block;
            max-width: 100%;
            max-height: 100%;
            /* ãƒ•ãƒ©ãƒƒã‚·ãƒ¥é˜²æ­¢: transform-originã‚’ä¸­å¤®ã«è¨­å®š */
            transform-origin: center center;
        }
        
        /* drawioå‡¦ç†ä¸­ã®éè¡¨ç¤ºã‚¯ãƒ©ã‚¹ */
        .svg-processing {
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        /* drawioè¡¨ç¤ºæº–å‚™å®Œäº†ã‚¯ãƒ©ã‚¹ */
        .svg-ready {
            visibility: visible !important;
            opacity: 1 !important;
            transition: opacity 0.2s ease-in-out, visibility 0s 0s !important;
        }
        
        /* ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã®å¼·åˆ¶è¡¨ç¤º */
        #flow-diagram {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .placeholder {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 40px 20px;
        }

        .error-message {
            color: #d32f2f;
            background: #ffebee;
            border: 1px solid #ffcdd2;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }

        .success-message {
            color: #388e3c;
            background: #e8f5e8;
            border: 1px solid #c8e6c9;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
        }


        .placeholder {
            color: #94a3b8;
            font-style: italic;
            text-align: center;
            padding: 40px 20px;
            background: #f8fafc;
            border-radius: 6px;
            border: 1px dashed #cbd5e1;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 1024px) {
            .demo-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                height: auto;
                min-height: calc(100vh - 120px);
            }
            
            .left-panel {
                order: 2;
            }
            
            .panel {
                min-height: 300px;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn {
                justify-content: center;
            }
        }

        /* drawioã‚³ãƒ¼ãƒ‰ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ */
        .code-section {
            position: relative;
        }

        .copy-code-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #code-panel:hover .copy-code-btn {
            opacity: 1;
        }

        .copy-code-btn:hover {
            background: #ffffff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .copy-code-btn:active {
            transform: translateY(0);
        }

        .copy-code-btn.copied {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        .copy-code-btn i {
            font-size: 14px;
        }

        .copy-tooltip {
            position: absolute;
            bottom: -30px;
            right: 0;
            background: #1e293b;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .copy-tooltip.show {
            opacity: 1;
        }

        .copy-tooltip::before {
            content: '';
            position: absolute;
            top: -4px;
            right: 12px;
            width: 8px;
            height: 8px;
            background: #1e293b;
            transform: rotate(45deg);
        }

        /* ãƒ•ãƒ­ãƒ¼å›³ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ */
        #diagram-panel {
            position: relative;
        }

        .download-diagram-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #diagram-panel:hover .download-diagram-btn {
            opacity: 1;
        }

        .download-diagram-btn:hover {
            background: #ffffff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .download-diagram-btn:active {
            transform: translateY(0);
        }

        .download-diagram-btn.downloading {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .download-diagram-btn i {
            font-size: 14px;
        }

        .download-tooltip {
            position: absolute;
            bottom: -30px;
            right: 0;
            background: #1e293b;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .download-tooltip.show {
            opacity: 1;
        }

        .download-tooltip::before {
            content: '';
            position: absolute;
            top: -4px;
            right: 12px;
            width: 8px;
            height: 8px;
            background: #1e293b;
            transform: rotate(45deg);
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="https://bit-company.jp/" target="_blank" rel="noopener noreferrer" class="header-logo-link">
            <img src="images/bit_logo.png" alt="BiT & Company" class="header-logo">
        </a>
        <h1>BiT-Flow</h1>
    </div>


    <div class="demo-container">
        <!-- å·¦é ˜åŸŸ: ãƒãƒ£ãƒƒãƒˆ + drawioã‚³ãƒ¼ãƒ‰ -->
        <div class="left-panel">
            <!-- ãƒãƒ£ãƒƒãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆä¸ŠåŠåˆ†ï¼‰ -->
            <div class="chat-section">
                <div class="panel" id="chat-panel">
                    <div class="panel-header">
                        <span><i class="fas fa-comments"></i> BiT-Flow ãƒãƒ£ãƒƒãƒˆ</span>
                        <span class="panel-status" id="chat-status">å¾…æ©Ÿä¸­</span>
                    </div>
                    <div class="panel-content" style="display: flex; flex-direction: column; height: 100%;">
                        <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã‚¨ãƒªã‚¢ -->
                        <div id="chat-messages" style="flex: 1; overflow-y: auto; padding: 16px; border: 1px solid rgba(209, 213, 219, 0.3); border-radius: 12px; margin-bottom: 16px; background: rgba(249, 250, 251, 0.5);">
                        </div>
                        
                        <!-- å…¥åŠ›ã‚¨ãƒªã‚¢ -->
                        <div style="display: flex; gap: 12px;">
                            <textarea 
                                id="prompt-input" 
                                placeholder="æ¥­å‹™ãƒ•ãƒ­ãƒ¼å›³ã‚’ç”Ÿæˆã—ãŸã„å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚&#10;ä¾‹: ECã‚µã‚¤ãƒˆã®æ³¨æ–‡å‡¦ç†æ¥­å‹™ãƒ•ãƒ­ãƒ¼ã‚’æã„ã¦"
                                style="flex: 1; resize: none; height: 60px; border: 2px solid rgba(209, 213, 219, 0.3); border-radius: 12px; padding: 12px; font-size: 14px; background: rgba(255, 255, 255, 0.9); font-family: inherit;"
                            ></textarea>
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                <button class="btn btn-primary" id="generate-btn" style="height: 32px; padding: 6px 16px;">
                                    <span id="btn-text">é€ä¿¡</span>
                                    <div id="btn-spinner" class="loading-spinner" style="display: none;"></div>
                                </button>
                                <button class="btn btn-secondary" id="clear-btn" style="height: 26px; padding: 4px 12px; font-size: 12px;">
                                    ã‚¯ãƒªã‚¢
                                </button>
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>

            <!-- drawioã‚³ãƒ¼ãƒ‰ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆä¸‹åŠåˆ†ï¼‰ -->
            <div class="code-section">
                <div class="panel" id="code-panel">
                    <div class="panel-header">
                        <span><i class="fas fa-code"></i> drawioã‚³ãƒ¼ãƒ‰</span>
                        <span class="panel-status" id="code-status">å¾…æ©Ÿä¸­</span>
                    </div>
                    <div class="panel-content">
                        <button class="copy-code-btn" id="copy-svg-btn" title="drawioã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼">
                            <i class="fas fa-copy"></i>
                            <span>ã‚³ãƒ”ãƒ¼</span>
                            <div class="copy-tooltip">drawioã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼</div>
                        </button>
                        <div id="svg-code" class="placeholder">
                            ç”Ÿæˆã•ã‚ŒãŸdrawioã‚³ãƒ¼ãƒ‰ãŒã“ã“ã«æ®µéšçš„ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å³é ˜åŸŸ: ãƒ•ãƒ­ãƒ¼å›³è¡¨ç¤ºãƒ‘ãƒãƒ«ï¼ˆç”»é¢ã®å³åŠåˆ†ï¼‰ -->
        <div class="panel" id="diagram-panel">
            <div class="panel-header">
                <span><i class="fas fa-project-diagram"></i> ãƒ•ãƒ­ãƒ¼å›³</span>
                <span class="panel-status" id="diagram-status">å¾…æ©Ÿä¸­</span>
            </div>
            <div class="panel-content">
                <button class="download-diagram-btn" id="download-svg-btn" title="drawioãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰">
                    <i class="fas fa-download"></i>
                    <span>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</span>
                    <div class="download-tooltip">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼</div>
                </button>
                <div id="flow-diagram" class="placeholder">
                    ç”Ÿæˆã•ã‚ŒãŸæ¥­å‹™ãƒ•ãƒ­ãƒ¼å›³ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
                </div>
            </div>
        </div>
    </div>

    <!-- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="prompt-modal" class="prompt-modal">
        <div class="prompt-modal-content">
            <div class="prompt-modal-header">
                <h3 class="prompt-modal-title">å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè©³ç´°</h3>
                <button class="prompt-modal-close" id="prompt-modal-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="prompt-modal-body" id="prompt-modal-body">
                <!-- å‹•çš„ã«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒæŒ¿å…¥ã•ã‚Œã‚‹ -->
            </div>
        </div>
    </div>

    <script>
        class BiTFlowProxyDemo {
            constructor() {
                this.baseUrl = 'http://localhost:3002';
                this.isGenerating = false;
                this.currentStream = null;
                this.svgStarted = false;
                this.accumulatedSvgCode = '';
                this.updateTimer = null; // ãƒ‡ãƒã‚¦ãƒ³ã‚¹ã‚¿ã‚¤ãƒãƒ¼
                this.svgDisplayed = false; // drawioè¡¨ç¤ºçŠ¶æ…‹
                
                // MXGraphé–¢é€£
                this.currentGraph = null; // ç¾åœ¨ã®ã‚°ãƒ©ãƒ•ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
                this.parsedCells = new Set(); // æ—¢ã«ãƒ‘ãƒ¼ã‚¹ã—ãŸã‚»ãƒ«ã®IDã‚’è¨˜éŒ²
                this.mxgraphInitialized = false; // MXGraphåˆæœŸåŒ–ãƒ•ãƒ©ã‚°
                
                // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå±¥æ­´ã‚’ä¿å­˜ã™ã‚‹ãƒãƒƒãƒ—ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã‚’ã‚­ãƒ¼ã¨ã™ã‚‹ï¼‰
                this.promptHistory = new Map();
                this.messageIdCounter = 0;
                
                // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDç”Ÿæˆï¼ˆãƒ–ãƒ©ã‚¦ã‚¶ã”ã¨ã«ä¸€æ„ï¼‰
                this.sessionId = this.getOrCreateSessionId();
                console.log('ã‚»ãƒƒã‚·ãƒ§ãƒ³ID:', this.sessionId);
                
                this.initializeElements();
                this.attachEventListeners();
                this.updateButtonState(); // åˆæœŸçŠ¶æ…‹ã‚’æ­£ã—ãè¨­å®š
                this.checkConnection();
                
                console.log('BiT-Flow ãƒ—ãƒ­ã‚­ã‚·ãƒ‡ãƒ¢åˆæœŸåŒ–å®Œäº†');
            }
            
            // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã®å–å¾—ã¾ãŸã¯ç”Ÿæˆ
            getOrCreateSessionId() {
                const key = 'bitflow_session_id';
                let sessionId = localStorage.getItem(key);
                
                if (!sessionId) {
                    // æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ç”Ÿæˆ
                    sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem(key, sessionId);
                    console.log('æ–°ã—ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ç”Ÿæˆã—ã¾ã—ãŸ:', sessionId);
                } else {
                    console.log('æ—¢å­˜ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’ä½¿ç”¨:', sessionId);
                }
                
                return sessionId;
            }

            initializeElements() {
                // DOMè¦ç´ ã®å–å¾—
                this.elements = {
                    promptInput: document.getElementById('prompt-input'),
                    generateBtn: document.getElementById('generate-btn'),
                    clearBtn: document.getElementById('clear-btn'),
                    chatMessages: document.getElementById('chat-messages'),
                    svgCode: document.getElementById('svg-code'),
                    flowDiagram: document.getElementById('flow-diagram'),
                    btnText: document.getElementById('btn-text'),
                    btnSpinner: document.getElementById('btn-spinner'),
                    
                    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
                    chatStatus: document.getElementById('chat-status'),
                    codeStatus: document.getElementById('code-status'),
                    diagramStatus: document.getElementById('diagram-status'),
                    
                    // ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³
                    copySvgBtn: document.getElementById('copy-svg-btn'),
                    
                    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
                    downloadSvgBtn: document.getElementById('download-svg-btn'),
                    
                    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ 
                    promptModal: document.getElementById('prompt-modal'),
                    promptModalBody: document.getElementById('prompt-modal-body'),
                    promptModalClose: document.getElementById('prompt-modal-close')
                };
                
                // é‡è¦ãªè¦ç´ ã®å­˜åœ¨ç¢ºèª
                console.log('DOMè¦ç´ å–å¾—çµæœ:');
                console.log('promptInput:', this.elements.promptInput);
                console.log('generateBtn:', this.elements.generateBtn);
                console.log('generateBtn disabled:', this.elements.generateBtn ? this.elements.generateBtn.disabled : 'undefined');
                
                // é€ä¿¡ãƒœã‚¿ãƒ³ãŒå–å¾—ã§ããªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
                if (!this.elements.generateBtn) {
                    console.error('é€ä¿¡ãƒœã‚¿ãƒ³ (generate-btn) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼');
                }
                
                if (!this.elements.promptInput) {
                    console.error('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ› (prompt-input) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼');
                }
            }

            attachEventListeners() {
                console.log('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šé–‹å§‹');
                
                // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                if (this.elements.generateBtn) {
                    this.elements.generateBtn.addEventListener('click', (e) => {
                        console.log('ğŸ”µ Generate button clicked!');
                        console.log('ğŸ” ã‚¯ãƒªãƒƒã‚¯æ™‚ã®çŠ¶æ…‹:', {
                            isGenerating: this.isGenerating,
                            buttonDisabled: this.elements.generateBtn.disabled,
                            inputValue: this.elements.promptInput ? this.elements.promptInput.value : 'N/A',
                            hasInput: this.elements.promptInput ? this.elements.promptInput.value.trim().length > 0 : false
                        });
                        e.preventDefault();
                        e.stopPropagation(); // ã‚¤ãƒ™ãƒ³ãƒˆã®ä¼æ’­ã‚’åœæ­¢
                        this.generateFlow();
                    });
                    console.log('âœ… Generate button ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†');
                    
                    // ãƒœã‚¿ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’ç¢ºèª
                    console.log('ğŸ” åˆæœŸãƒœã‚¿ãƒ³çŠ¶æ…‹:', {
                        exists: true,
                        disabled: this.elements.generateBtn.disabled,
                        style: {
                            display: window.getComputedStyle(this.elements.generateBtn).display,
                            visibility: window.getComputedStyle(this.elements.generateBtn).visibility,
                            pointerEvents: window.getComputedStyle(this.elements.generateBtn).pointerEvents
                        }
                    });
                } else {
                    console.error('âŒ Generate button ãŒå­˜åœ¨ã—ãªã„ãŸã‚ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®šã§ãã¾ã›ã‚“');
                }

                if (this.elements.clearBtn) {
                    this.elements.clearBtn.addEventListener('click', (e) => {
                        console.log('Clear button clicked');
                        e.preventDefault();
                        this.clearAll();
                    });
                } else {
                    console.error('Clear button ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                }

                // ã‚³ãƒ”ãƒ¼ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                if (this.elements.copySvgBtn) {
                    this.elements.copySvgBtn.addEventListener('click', (e) => {
                        console.log('Copy drawio button clicked');
                        e.preventDefault();
                        this.copySvgCode();
                    });
                    console.log('Copy drawio button ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†');
                } else {
                    console.error('Copy drawio button ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                }
                
                // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
                if (this.elements.downloadSvgBtn) {
                    this.elements.downloadSvgBtn.addEventListener('click', (e) => {
                        console.log('Download drawio button clicked');
                        e.preventDefault();
                        this.downloadSvgFile();
                    });
                    console.log('Download drawio button ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†');
                } else {
                    console.error('Download drawio button ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                }

                // ãƒ¢ãƒ¼ãƒ€ãƒ«é–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆ
                if (this.elements.promptModalClose) {
                    this.elements.promptModalClose.addEventListener('click', () => {
                        this.closePromptModal();
                    });
                }

                if (this.elements.promptModal) {
                    // ãƒ¢ãƒ¼ãƒ€ãƒ«èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
                    this.elements.promptModal.addEventListener('click', (e) => {
                        if (e.target === this.elements.promptModal) {
                            this.closePromptModal();
                        }
                    });
                    
                    // ESCã‚­ãƒ¼ã§é–‰ã˜ã‚‹
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape' && this.elements.promptModal.classList.contains('show')) {
                            this.closePromptModal();
                        }
                    });
                }

                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
                if (this.elements.promptInput) {
                    this.elements.promptInput.addEventListener('keydown', (e) => {
                        if (e.ctrlKey && e.key === 'Enter' && !this.isGenerating) {
                            e.preventDefault();
                            this.generateFlow();
                        }
                    });

                    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›ç›£è¦–
                    this.elements.promptInput.addEventListener('input', (e) => {
                        console.log('ğŸ“ å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆç™ºç”Ÿ:', {
                            value: e.target.value,
                            length: e.target.value.length,
                            trimmedLength: e.target.value.trim().length
                        });
                        this.updateButtonState();
                    });
                    console.log('âœ… Prompt input ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†');
                } else {
                    console.error('Prompt input ãŒå­˜åœ¨ã—ãªã„ãŸã‚ã€ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®šã§ãã¾ã›ã‚“');
                }
                
                console.log('ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†');
            }

            // ãƒœã‚¿ãƒ³çŠ¶æ…‹æ›´æ–°é–¢æ•°
            updateButtonState() {
                if (!this.elements.generateBtn) {
                    console.error('updateButtonState: generateBtn ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                if (!this.elements.promptInput) {
                    console.error('updateButtonState: promptInput ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                const inputValue = this.elements.promptInput.value;
                const hasContent = inputValue.trim().length > 0;
                const shouldDisable = this.isGenerating || !hasContent;
                
                // ãƒœã‚¿ãƒ³ã®disabledå±æ€§ã‚’è¨­å®š
                this.elements.generateBtn.disabled = shouldDisable;
                
                // ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚‚æ›´æ–°ï¼ˆè¦–è¦šçš„ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
                if (shouldDisable) {
                    this.elements.generateBtn.style.opacity = '0.5';
                    this.elements.generateBtn.style.cursor = 'not-allowed';
                } else {
                    this.elements.generateBtn.style.opacity = '1';
                    this.elements.generateBtn.style.cursor = 'pointer';
                }
                
                this.updateStatus('chat', hasContent ? 'å…¥åŠ›æ¸ˆã¿' : 'å¾…æ©Ÿä¸­');
                
                console.log('ğŸ” ãƒœã‚¿ãƒ³çŠ¶æ…‹æ›´æ–°è©³ç´°:', {
                    inputValue: inputValue,
                    hasContent: hasContent,
                    isGenerating: this.isGenerating,
                    shouldDisable: shouldDisable,
                    actualDisabled: this.elements.generateBtn.disabled,
                    buttonExists: !!this.elements.generateBtn,
                    inputExists: !!this.elements.promptInput
                });
            }

            updateStatus(panel, status) {
                const statusElement = this.elements[`${panel}Status`];
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }

            updateConnectionStatus(status, message) {
                // æ¥ç¶šã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã¯å‰Šé™¤æ¸ˆã¿ãªã®ã§ä½•ã‚‚ã—ãªã„
                console.log(`æ¥ç¶šçŠ¶æ…‹: ${status} - ${message}`);
            }

            async checkConnection() {
                console.log('ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šç¢ºèªé–‹å§‹');
                this.updateConnectionStatus('checking', 'æ¥ç¶šç¢ºèªä¸­...');
                
                try {
                    const response = await fetch(`${this.baseUrl}/api/health`, {
                        method: 'GET',
                        timeout: 5000
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('æ¥ç¶šæˆåŠŸ:', data);
                        this.updateConnectionStatus('connected', 'ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šOK');
                        return true;
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error('æ¥ç¶šå¤±æ•—:', error);
                    this.updateConnectionStatus('disconnected', 'ã‚µãƒ¼ãƒãƒ¼æ¥ç¶šå¤±æ•—');
                    this.showError('ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                    return false;
                }
            }

            preparePrompt(userPrompt) {
                // 2å›ç›®ä»¥é™ã®ä¿®æ­£æŒ‡ç¤ºã«ã‚‚å¯¾å¿œã™ã‚‹ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’ãã®ã¾ã¾ä½¿ç”¨
                console.log('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæº–å‚™: ã‚»ãƒƒã‚·ãƒ§ãƒ³ID', this.sessionId);
                console.log('ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:', userPrompt);
                
                // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ™ãƒ¼ã‚¹ã®åˆ¶å¾¡ã¯ã‚µãƒ¼ãƒãƒ¼å´ã§è¡Œã†ãŸã‚ã€
                // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ã¯ç‰¹åˆ¥ãªå‡¦ç†ã‚’è¡Œã‚ãªã„
                return userPrompt;
            }

            async generateFlow() {
                console.log('ğŸš€ generateFlow() å‘¼ã³å‡ºã—é–‹å§‹');
                console.log('ğŸ” ç¾åœ¨ã®çŠ¶æ…‹è©³ç´°:', {
                    isGenerating: this.isGenerating,
                    generateBtnExists: !!this.elements.generateBtn,
                    generateBtnDisabled: this.elements.generateBtn ? this.elements.generateBtn.disabled : 'N/A',
                    promptInputExists: !!this.elements.promptInput,
                    promptInputValue: this.elements.promptInput ? this.elements.promptInput.value : 'N/A',
                    promptInputLength: this.elements.promptInput ? this.elements.promptInput.value.length : 'N/A'
                });
                
                if (!this.elements.promptInput) {
                    console.error('promptInput ãŒå­˜åœ¨ã—ã¾ã›ã‚“ï¼');
                    this.showError('ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                const userPrompt = this.elements.promptInput.value.trim();
                console.log('ğŸ“ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:', userPrompt);
                
                if (!userPrompt) {
                    console.log('âš ï¸ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒç©ºã§ã™');
                    this.showError('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                    return;
                }

                if (this.isGenerating) {
                    console.log('âš ï¸ æ—¢ã«ç”Ÿæˆä¸­ã®ãŸã‚ç„¡è¦–');
                    return;
                }

                console.log('ãƒ•ãƒ­ãƒ¼ç”Ÿæˆé–‹å§‹:', userPrompt);
                
                try {
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                    this.addUserMessage(userPrompt);
                    
                    // å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢ï¼ˆé€ä¿¡å¾Œã™ãã«ã‚¯ãƒªã‚¢ï¼‰
                    this.elements.promptInput.value = '';
                    this.updateButtonState(); // ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚‚æ›´æ–°
                    console.log('ğŸ“ å…¥åŠ›ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
                    
                    this.startGenerating();
                    
                    // æ¥ç¶šç¢ºèª
                    const isConnected = await this.checkConnection();
                    if (!isConnected) {
                        throw new Error('ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“');
                    }

                    const fullPrompt = this.preparePrompt(userPrompt);
                    const streaming = true;
                    
                    console.log('é€ä¿¡ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:', fullPrompt);
                    console.log('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°:', streaming);

                    if (streaming) {
                        await this.generateFlowStreaming(fullPrompt);
                    } else {
                        await this.generateFlowBatch(fullPrompt);
                    }

                } catch (error) {
                    console.error('ãƒ•ãƒ­ãƒ¼ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                    this.hideTypingIndicator();
                    this.showError(`ãƒ•ãƒ­ãƒ¼ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
                } finally {
                    // ç¢ºå®Ÿã«ç”ŸæˆçŠ¶æ…‹ã‚’çµ‚äº†
                    this.stopGenerating();
                    this.hideTypingIndicator();
                }
            }

            async generateFlowStreaming(prompt) {
                console.log('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ç”Ÿæˆé–‹å§‹');
                
                this.updateStatus('response', 'ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­');
                this.updateStatus('code', 'è§£æå¾…æ©Ÿä¸­');
                this.updateStatus('diagram', 'æç”»å¾…æ©Ÿä¸­');

                try {
                    const response = await fetch(`${this.baseUrl}/api/claude/messages`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            streaming: true,
                            sessionId: this.sessionId
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }

                    this.currentStream = response;
                    await this.handleStreamingResponse(response);

                } catch (error) {
                    console.error('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }

            async handleStreamingResponse(response) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullContent = '';

                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) {
                            console.log('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å®Œäº†');
                            break;
                        }

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim() === '') continue;

                            try {
                                const data = JSON.parse(line);
                                console.log('ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿:', data);

                                if (data.type === 'start') {
                                    console.log('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é–‹å§‹:', data.message);
                                    this.showTypingIndicator();
                                    
                                    // å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä¿å­˜ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰é€ã‚‰ã‚Œã¦ããŸå ´åˆï¼‰
                                    if (data.actualPrompt && this.currentMessageId) {
                                        const promptData = this.promptHistory.get(this.currentMessageId);
                                        if (promptData) {
                                            promptData.actualPrompt = data.actualPrompt;
                                            console.log('å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä¿å­˜:', this.currentMessageId);
                                        }
                                    }
                                    
                                } else if (data.type === 'content') {
                                    fullContent += data.text;
                                    this.updateAssistantMessage(fullContent);
                                    
                                    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ SVGå‡¦ç†
                                    this.processStreamingSVG(data.text, fullContent);
                                    
                                } else if (data.type === 'complete') {
                                    console.log('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆå—ä¿¡:', data.totalChunks, 'ãƒãƒ£ãƒ³ã‚¯');
                                    console.log('å®Œäº†æ™‚ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é•·:', data.fullContent ? data.fullContent.length : 'ãªã—');
                                    this.hideTypingIndicator();
                                    this.updateStatus('chat', 'å®Œäº†');
                                    this.finalizeGeneration(data.fullContent || fullContent);
                                    
                                } else if (data.type === 'error') {
                                    console.error('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', data.error);
                                    this.hideTypingIndicator();
                                    throw new Error(data.error);
                                }
                            } catch (parseError) {
                                console.warn('JSONè§£æã‚¨ãƒ©ãƒ¼:', parseError, 'Line:', line);
                            }
                        }
                    }
                } catch (error) {
                    console.error('ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }

            async generateFlowBatch(prompt) {
                console.log('ãƒãƒƒãƒç”Ÿæˆé–‹å§‹');
                
                this.updateStatus('chat', 'APIå‘¼ã³å‡ºã—ä¸­');
                this.showTypingIndicator();
                
                try {
                    const response = await fetch(`${this.baseUrl}/api/claude/messages-batch`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            sessionId: this.sessionId
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }

                    const result = await response.json();
                    console.log('ãƒãƒƒãƒç”Ÿæˆå®Œäº†:', result);

                    // å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä¿å­˜ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰é€ã‚‰ã‚Œã¦ããŸå ´åˆï¼‰
                    if (result.actualPrompt && this.currentMessageId) {
                        const promptData = this.promptHistory.get(this.currentMessageId);
                        if (promptData) {
                            promptData.actualPrompt = result.actualPrompt;
                            console.log('å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ä¿å­˜ï¼ˆãƒãƒƒãƒï¼‰:', this.currentMessageId);
                        }
                    }

                    this.hideTypingIndicator();
                    this.updateAssistantMessage(result.content);
                    this.updateStatus('chat', 'å®Œäº†');
                    this.finalizeGeneration(result.content);

                } catch (error) {
                    console.error('ãƒãƒƒãƒç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }

            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ SVGå‡¦ç†
            processStreamingSVG(newText, fullContent) {
                // drawioé–‹å§‹ã®æ¤œå‡º
                if (!this.svgStarted && (newText.includes('<?xml') || newText.includes('<mxfile'))) {
                    console.log('drawioã‚³ãƒ¼ãƒ‰é–‹å§‹ã‚’æ¤œå‡º');
                    this.svgStarted = true;
                    this.accumulatedSvgCode = '';
                    this.updateStatus('code', 'drawioç”Ÿæˆä¸­');
                }

                // SVGä¸­ã®å ´åˆã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è“„ç©
                if (this.svgStarted) {
                    this.accumulatedSvgCode += newText;
                    
                    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§drawioã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºï¼ˆã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆä»˜ãï¼‰
                    this.displaySVGCode(this.accumulatedSvgCode);
                    this.forceScroll(this.elements.svgCode);
                    
                    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ•ãƒ­ãƒ¼å›³ã‚’å¼·åˆ¶æ›´æ–°
                    this.forceUpdateFlowDiagram(this.accumulatedSvgCode);
                    
                    // drawioçµ‚äº†ã‚’æ¤œå‡ºã—ã¦æœ€çµ‚æ›´æ–°
                    if (this.accumulatedSvgCode.includes('</mxfile>')) {
                        console.log('drawioã‚³ãƒ¼ãƒ‰å®Œäº†ã‚’æ¤œå‡º');
                        this.updateStatus('code', 'drawioå®Œäº†');
                        
                        // å®Œå…¨ãªdrawioã‚’æŠ½å‡ºã—ã¦ãƒ•ãƒ­ãƒ¼å›³ã‚’æ›´æ–°
                        const svgMatch = this.accumulatedSvgCode.match(/<\?xml[\s\S]*?<\/mxfile>|<mxfile[\s\S]*?<\/mxfile>/);
                        if (svgMatch) {
                            this.updateFlowDiagram(svgMatch[0]);
                        }
                    }
                }
            }

            // drawioã‚³ãƒ¼ãƒ‰ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºï¼ˆé©åˆ‡ãªã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå¯¾å¿œï¼‰
            displaySVGCode(svgCode) {
                try {
                    console.log('displayDrawioCode - å…¥åŠ›drawioã‚³ãƒ¼ãƒ‰ã®æœ€åˆã®100æ–‡å­—:', svgCode.substring(0, 100));
                    
                    // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’é©åˆ‡ã«æ•´ç†
                    const formattedCode = this.formatSVGCode(svgCode);
                    console.log('formatDrawioCodeå¾Œã®æœ€åˆã®100æ–‡å­—:', formattedCode.substring(0, 100));
                    
                    // HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                    let escapedCode = formattedCode
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;');

                    // ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆé©ç”¨ï¼ˆã‚ˆã‚Šå®‰å…¨ãªæ–¹æ³•ï¼‰
                    let highlightedCode = escapedCode;
                    
                    // å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å€‹åˆ¥ã«å‡¦ç†ï¼ˆé †åºé‡è¦ï¼‰
                    // 1. ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…ˆã«å‡¦ç†
                    highlightedCode = highlightedCode.replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="svg-comment">$1</span>');
                    
                    // 2. XMLå®£è¨€
                    highlightedCode = highlightedCode.replace(/(&lt;\?xml[\s\S]*?\?&gt;)/g, '<span class="svg-tag">$1</span>');
                    
                    // 3. å®Œå…¨ãªã‚¿ã‚°ï¼ˆé–‹å§‹ã‚¿ã‚°ã¨çµ‚äº†ã‚¿ã‚°ï¼‰ã‚’ä¸€åº¦ã«å‡¦ç†
                    highlightedCode = highlightedCode.replace(/(&lt;\/?)([a-zA-Z][\w\-:]*)((?:\s+[\w\-:]+(?:=&quot;[^&]*&quot;)?)*\s*)(\/?)(&gt;)/g, 
                        function(match, openBracket, tagName, attributes, selfClose, closeBracket) {
                            // ã‚¿ã‚°åã¨ãƒ–ãƒ©ã‚±ãƒƒãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                            let result = '<span class="svg-tag">' + openBracket + tagName + '</span>';
                            
                            // å±æ€§ã‚’å‡¦ç†
                            if (attributes) {
                                result += attributes.replace(/(\s+)([\w\-:]+)(=)(&quot;)([^&]*)(&quot;)/g, 
                                    '$1<span class="svg-attribute">$2</span>$3$4<span class="svg-value">$5</span>$6');
                            }
                            
                            // é–‰ã˜ãƒ–ãƒ©ã‚±ãƒƒãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                            result += '<span class="svg-tag">' + selfClose + closeBracket + '</span>';
                            
                            return result;
                        }
                    );

                    this.elements.svgCode.innerHTML = highlightedCode;
                    // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
                    this.elements.svgCode.classList.remove('placeholder');
                } catch (error) {
                    console.warn('ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§è¡¨ç¤º
                    this.elements.svgCode.textContent = svgCode;
                    // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
                    this.elements.svgCode.classList.remove('placeholder');
                }
            }

            // drawioã‚³ãƒ¼ãƒ‰ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ˆå³å¯„ã‚Šå•é¡Œå®Œå…¨è§£æ±ºç‰ˆï¼‰
            formatSVGCode(svgCode) {
                try {
                    // åŸºæœ¬çš„ãªæ”¹è¡Œã§åˆ†å‰²ã—ã€å®Œå…¨ã«æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä½œæˆ
                    const lines = svgCode.replace(/>\s*</g, '>\n<').split('\n');
                    let indentLevel = 0;
                    const indentSize = 2;
                    const formattedLines = [];
                    
                    for (let line of lines) {
                        // å…¨ã¦ã®å…ˆé ­ãƒ»æœ«å°¾ç©ºç™½ã‚’é™¤å»
                        const cleanLine = line.trim();
                        if (!cleanLine) continue;
                        
                        // é–‰ã˜ã‚¿ã‚°ã€XMLãƒ˜ãƒƒãƒ€ãƒ¼ã€ã‚³ãƒ¡ãƒ³ãƒˆã€è‡ªå·±çµ‚äº†ã‚¿ã‚°ã®å‡¦ç†
                        let isClosingTag = cleanLine.startsWith('</');
                        let isXmlHeader = cleanLine.startsWith('<?');
                        let isComment = cleanLine.startsWith('<!--');
                        let isSelfClosing = cleanLine.endsWith('/>');
                        let isTextContent = !cleanLine.startsWith('<');
                        
                        // é–‰ã˜ã‚¿ã‚°ã¯å…ˆã«ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä¸‹ã’ã‚‹
                        if (isClosingTag) {
                            indentLevel = Math.max(0, indentLevel - 1);
                        }
                        
                        // å®Œå…¨ã«æ–°ã—ã„ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä½œæˆï¼ˆæ—¢å­˜ã®ç©ºç™½ã¯ä¸€åˆ‡è€ƒæ…®ã—ãªã„ï¼‰
                        let finalIndent = '';
                        if (!isXmlHeader) { // XMLãƒ˜ãƒƒãƒ€ãƒ¼ã¯ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãªã—
                            finalIndent = ' '.repeat(indentLevel * indentSize);
                        }
                        
                        // è¡Œã‚’è¿½åŠ 
                        formattedLines.push(finalIndent + cleanLine);
                        
                        // é–‹å§‹ã‚¿ã‚°ã®å ´åˆã¯ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä¸Šã’ã‚‹
                        if (!isClosingTag && !isXmlHeader && !isComment && !isSelfClosing && !isTextContent && cleanLine.startsWith('<')) {
                            // ãƒ†ã‚­ã‚¹ãƒˆã‚’å«ã‚€ä¸€è¡Œã‚¿ã‚°ã§ãªã„å ´åˆã®ã¿ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’ä¸Šã’ã‚‹
                            if (!cleanLine.includes('><') && !cleanLine.match(/<[^>]+>[^<]+<\/[^>]+>/)) {
                                indentLevel++;
                            }
                        }
                    }
                    
                    const result = formattedLines.join('\n');
                    console.log('ğŸ¨ drawioãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå®Œäº†:', { 
                        originalLines: lines.length, 
                        formattedLines: formattedLines.length,
                        maxIndent: Math.max(...formattedLines.map(line => (line.match(/^ */)[0].length) / indentSize))
                    });
                    
                    return result;
                    
                } catch (error) {
                    console.warn('drawioãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãã®ã¾ã¾è¡¨ç¤º
                    return svgCode;
                }
            }

            // å¼·åˆ¶ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ãƒ­ãƒ¼å›³æ›´æ–°
            forceUpdateFlowDiagram(svgCode) {
                try {
                    // SVGãŒååˆ†ãªé•·ã•ã«ãªã£ãŸã‚‰è¡¨ç¤ºã‚’è©¦è¡Œ
                    if (svgCode.length < 200) return;
                    
                    // åŸºæœ¬çš„ãªdrawioæ§‹é€ ã‚’ãƒã‚§ãƒƒã‚¯
                    if (!svgCode.includes('<mxfile') && !svgCode.includes('<mxGraphModel')) return;
                    
                    // æ›´æ–°é »åº¦ã‚’åˆ¶é™ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼‰
                    if (this.updateTimer) {
                        clearTimeout(this.updateTimer);
                    }
                    
                    this.updateTimer = setTimeout(() => {
                        this._doForceUpdateFlowDiagram(svgCode);
                    }, 10); // 10msã®ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼ˆè¶…é«˜é€Ÿæ›´æ–°ï¼‰
                    
                } catch (error) {
                    console.debug('ãƒ•ãƒ­ãƒ¼å›³æ›´æ–°ã‚¹ã‚­ãƒƒãƒ—:', error.message);
                }
            }
            
            // å®Ÿéš›ã®æ›´æ–°å‡¦ç†
            _doForceUpdateFlowDiagram(drawioCode) {
                console.log('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»å®Ÿè¡Œ:', drawioCode.length, 'æ–‡å­—');
                
                // MXGraphãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
                if (typeof mxGraph === 'undefined') {
                    console.error('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                // ä¸å®Œå…¨ãªdrawioã‚³ãƒ¼ãƒ‰ã‚’è£œå®Œ
                let displayCode = drawioCode;
                
                // XMLãƒ˜ãƒƒãƒ€ãƒ¼è¿½åŠ 
                if (!displayCode.includes('<?xml')) {
                    displayCode = '<?xml version="1.0" encoding="UTF-8"?>\n' + displayCode;
                }
                
                // ç°¡æ˜“çš„ã«ä¸å®Œå…¨ã‚¿ã‚°ã‚’è£œå®Œ
                if (!displayCode.includes('</mxfile>')) {
                    displayCode += '</mxfile>';
                }
                
                // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»å®Ÿè£…
                try {
                    // æ¯å›ã‚³ãƒ³ãƒ†ãƒŠã‚’æ–°ã—ãä½œæˆï¼ˆé‡è¦ï¼šä¸‹ã«è¿½åŠ ã•ã‚Œã‚‹ã®ã‚’é˜²ãï¼‰
                    console.log('MXGraphã‚³ãƒ³ãƒ†ãƒŠã‚’æ–°è¦ä½œæˆ');
                    this.elements.flowDiagram.innerHTML = '<div id="mxgraph-container" style="width: 100%; height: 100%; min-height: 600px; background: white; overflow: auto;"></div>';
                    
                    const container = document.getElementById('mxgraph-container');
                    if (!container) {
                        console.error('ã‚³ãƒ³ãƒ†ãƒŠãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        return;
                    }
                    
                    // å˜ç´”ã«æ¯å›æ–°ã—ã„ã‚°ãƒ©ãƒ•ã‚’ä½œæˆ
                    try {
                        const graph = new mxGraph(container);
                        graph.setEnabled(false);
                        
                        // Draw.ioäº’æ›ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
                        this.setupGraphStyles(graph);
                        
                        // XMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°
                        const escapeXmlAttribute = (str) => {
                            if (!str) return str;
                            return str
                                .replace(/&(?!amp;|lt;|gt;|quot;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;')
                                .replace(/"/g, '&quot;')
                                .replace(/'/g, '&#x27;');
                        };
                        
                        // displayCodeã®å±æ€§å€¤ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                        let escapedDisplayCode = displayCode;
                        escapedDisplayCode = escapedDisplayCode.replace(/(\w+)="([^"]*)"/g, (match, attrName, attrValue) => {
                            if (attrValue.includes('&lt;') || attrValue.includes('&gt;') || 
                                attrValue.includes('&amp;') || attrValue.includes('&quot;')) {
                                return match;
                            }
                            if (attrValue.includes('<') || attrValue.includes('>') || 
                                attrValue.includes('&') || attrValue.includes('"')) {
                                const escaped = escapeXmlAttribute(attrValue);
                                return `${attrName}="${escaped}"`;
                            }
                            return match;
                        });
                        
                        // drawio XMLã‚’ãƒ‘ãƒ¼ã‚¹
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(escapedDisplayCode, 'text/xml');
                        const codec = new mxCodec();
                        
                        // mxGraphModelã‚’æ¢ã™
                        const mxGraphModel = doc.querySelector('mxGraphModel');
                        if (mxGraphModel) {
                            codec.decode(mxGraphModel, graph.getModel());
                            
                            // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ­£ç¢ºã«é©ç”¨
                            this.fixGraphStyles(graph);
                        }
                        
                        // ãƒ•ãƒ­ãƒ¼å›³ã‚’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«åˆã‚ã›ã¦ãƒ•ã‚£ãƒƒãƒˆï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ï¼‰
                        try {
                            // èª¿æ•´ä¸­ã¯éè¡¨ç¤ºï¼ˆã¡ã‚‰ã¤ãé˜²æ­¢ï¼‰
                            container.style.visibility = 'hidden';
                            
                            graph.fit();
                            const bounds = graph.getGraphBounds();
                            if (bounds) {
                                const padding = 20;
                                const contentWidth = Math.min(bounds.width + (padding * 2), this.elements.flowDiagram.clientWidth - 10);
                                const contentHeight = Math.max(bounds.height + (padding * 2), 400);
                                
                                // ã‚µã‚¤ã‚ºã‚’ä¸€åº¦ã«è¨­å®š
                                requestAnimationFrame(() => {
                                    container.style.width = `${contentWidth}px`;
                                    container.style.height = `${contentHeight}px`;
                                    container.style.overflow = 'hidden';
                                    
                                    graph.sizeDidChange();
                                    graph.center(true, true);
                                    
                                    // è¡¨ç¤º
                                    container.style.visibility = 'visible';
                                });
                            } else {
                                container.style.visibility = 'visible';
                            }
                        } catch (fitError) {
                            console.log('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒƒãƒˆã‚¨ãƒ©ãƒ¼:', fitError.message);
                            container.style.visibility = 'visible';
                        }
                        
                        graph.refresh();
                        console.log('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»æˆåŠŸ');
                        this.updateStatus('diagram', 'æç”»ä¸­');
                        
                        // è¡¨ç¤ºå®Œäº†
                        this.elements.flowDiagram.classList.remove('svg-processing');
                        this.elements.flowDiagram.classList.add('svg-ready');
                        
                    } catch (e) {
                        console.debug('æç”»ã‚¨ãƒ©ãƒ¼:', e.message);
                    }
                    
                } catch (displayError) {
                    console.error('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»ã‚¨ãƒ©ãƒ¼:', displayError);
                }
            }
            
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚°ãƒ©ãƒ•ã®åˆæœŸåŒ–
            initializeRealtimeGraph() {
                if (!this.elements.flowDiagram) {
                    console.error('ãƒ•ãƒ­ãƒ¼å›³è¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç¢ºèª
                if (typeof mxGraph === 'undefined') {
                    console.error('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
                    return;
                }
                
                // å‡¦ç†ä¸­çŠ¶æ…‹ã«ã™ã‚‹
                this.elements.flowDiagram.classList.add('svg-processing');
                this.elements.flowDiagram.classList.remove('svg-ready');
                
                // MXGraphã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
                this.elements.flowDiagram.innerHTML = '<div id="mxgraph-container" style="width: 100%; height: 100%; background: white; overflow: auto;"></div>';
                const container = document.getElementById('mxgraph-container');
                
                if (!container) {
                    console.error('MXGraphã‚³ãƒ³ãƒ†ãƒŠã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                    return;
                }
                
                try {
                    // ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                    this.currentGraph = new mxGraph(container);
                    this.currentGraph.setEnabled(false); // ç·¨é›†ã‚’ç„¡åŠ¹åŒ–
                    
                    // ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
                    this.setupGraphStyles(this.currentGraph);
                    
                    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»ç”¨ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆæœŸåŒ–
                    this.vertexMap = new Map(); // IDã‹ã‚‰é ‚ç‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒãƒƒãƒ—
                    this.pendingEdges = []; // æ¥ç¶šå…ˆãŒè¦‹ã¤ã‹ã£ã¦ã„ãªã„ã‚¨ãƒƒã‚¸ã‚’ä¿å­˜
                    
                    console.log('ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚°ãƒ©ãƒ•åˆæœŸåŒ–å®Œäº†');
                } catch (error) {
                    console.error('ã‚°ãƒ©ãƒ•åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
                    throw error;
                }
            }
            
            // ã‚°ãƒ©ãƒ•ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®šï¼ˆDraw.ioäº’æ›ï¼‰
            setupGraphStyles(graph) {
                if (!graph || !graph.getStylesheet) {
                    console.error('ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹ã§ã™');
                    return;
                }
                
                // MXGraphã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å­˜åœ¨ç¢ºèª
                if (typeof mxConstants === 'undefined') {
                    console.warn('mxConstantsãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚åŸºæœ¬çš„ãªã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™');
                    return;
                }
                
                if (typeof mxCellRenderer === 'undefined') {
                    console.warn('mxCellRendererãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ã‚¤ãƒ—ç™»éŒ²ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™');
                }
                
                try {
                    const stylesheet = graph.getStylesheet();
                    
                    // Draw.ioäº’æ›ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
                    const defaultVertexStyle = stylesheet.getDefaultVertexStyle();
                    defaultVertexStyle[mxConstants.STYLE_FONTCOLOR] = '#000000';
                    defaultVertexStyle[mxConstants.STYLE_FONTFAMILY] = 'Helvetica, Arial, sans-serif';
                    defaultVertexStyle[mxConstants.STYLE_FONTSIZE] = '12';
                    defaultVertexStyle[mxConstants.STYLE_STROKECOLOR] = '#000000';
                    defaultVertexStyle[mxConstants.STYLE_STROKEWIDTH] = '1';
                    
                    // ã‚¨ãƒƒã‚¸ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«
                    const defaultEdgeStyle = stylesheet.getDefaultEdgeStyle();
                    defaultEdgeStyle[mxConstants.STYLE_STROKECOLOR] = '#000000';
                    defaultEdgeStyle[mxConstants.STYLE_STROKEWIDTH] = '1';
                    defaultEdgeStyle[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;
                    
                    // Draw.ioäº’æ›ã‚·ã‚§ã‚¤ãƒ—ã®ç™»éŒ²ï¼ˆmxCellRendererãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã®ã¿ï¼‰
                    if (typeof mxCellRenderer !== 'undefined') {
                        this.registerDrawioCompatibleShapes();
                    }
                    
                    console.log('Draw.ioäº’æ›ã‚¹ã‚¿ã‚¤ãƒ«ã®è¨­å®šå®Œäº†');
                    
                } catch (error) {
                    console.error('ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // Draw.ioäº’æ›ã‚·ã‚§ã‚¤ãƒ—ã®ç™»éŒ²
            registerDrawioCompatibleShapes() {
                try {
                    // swimlaneã‚·ã‚§ã‚¤ãƒ—ï¼ˆã‚¹ã‚¤ãƒ ãƒ¬ãƒ¼ãƒ³ï¼‰
                    if (typeof mxSwimlane !== 'undefined') {
                        mxCellRenderer.registerShape('swimlane', mxSwimlane);
                        console.log('swimlaneã‚·ã‚§ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
                    } else {
                        console.warn('mxSwimlaneãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
                    }
                    
                    // groupã‚·ã‚§ã‚¤ãƒ—ï¼ˆå‡¡ä¾‹ç”¨ï¼‰
                    if (typeof mxRectangleShape !== 'undefined') {
                        mxCellRenderer.registerShape('group', mxRectangleShape);
                        console.log('groupã‚·ã‚§ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
                    }
                    
                    // rhombusã‚·ã‚§ã‚¤ãƒ—ï¼ˆåˆ†å²ç”¨ã®ã²ã—å½¢ï¼‰
                    if (typeof mxRhombus !== 'undefined') {
                        mxCellRenderer.registerShape('rhombus', mxRhombus);
                        console.log('rhombusã‚·ã‚§ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
                    }
                    
                    // ellipseã‚·ã‚§ã‚¤ãƒ—ï¼ˆé–‹å§‹ãƒ»çµ‚äº†ç”¨ã®ä¸¸ï¼‰
                    if (typeof mxEllipse !== 'undefined') {
                        mxCellRenderer.registerShape('ellipse', mxEllipse);
                        console.log('ellipseã‚·ã‚§ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
                    }
                    
                    // cylinder3ã‚·ã‚§ã‚¤ãƒ—ï¼ˆDBã‚¢ã‚¤ã‚³ãƒ³ç”¨ï¼‰
                    if (typeof mxCylinder !== 'undefined') {
                        mxCellRenderer.registerShape('cylinder3', mxCylinder);
                        mxCellRenderer.registerShape('cylinder', mxCylinder); // ä¸¡æ–¹ã®åå‰ã§ç™»éŒ²
                        console.log('cylinder/cylinder3ã‚·ã‚§ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
                    }
                    
                    // documentã‚·ã‚§ã‚¤ãƒ—ï¼ˆDraw.ioäº’æ›ï¼‰
                    if (typeof mxShape !== 'undefined') {
                        function DrawioDocumentShape() {
                            mxShape.call(this);
                        }
                        
                        if (typeof mxUtils !== 'undefined' && typeof mxUtils.extend === 'function' && typeof mxShape !== 'undefined') {
                            mxUtils.extend(DrawioDocumentShape, mxShape);
                            
                            DrawioDocumentShape.prototype.paintBackground = function(c, x, y, w, h) {
                                const fold = Math.min(w * 0.2, h * 0.2, 20);
                                
                                console.log(`Drawing document at: x=${x}, y=${y}, w=${w}, h=${h}`);
                                
                                // æ­£ã—ã„åº§æ¨™ã§æç”»
                                c.begin();
                                c.moveTo(x, y);
                                c.lineTo(x + w - fold, y);
                                c.lineTo(x + w, y + fold);
                                c.lineTo(x + w, y + h);
                                c.lineTo(x, y + h);
                                c.close();
                                c.fillAndStroke();
                                
                                // æŠ˜ã‚Šè¿”ã—éƒ¨åˆ†
                                c.begin();
                                c.moveTo(x + w - fold, y);
                                c.lineTo(x + w - fold, y + fold);
                                c.lineTo(x + w, y + fold);
                                c.stroke();
                            };
                            
                            mxCellRenderer.registerShape('document', DrawioDocumentShape);
                            console.log('documentã‚·ã‚§ã‚¤ãƒ—ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
                        }
                    }
                    
                    // Note/Sticky noteã‚·ã‚§ã‚¤ãƒ—ã‚‚è¿½åŠ 
                    if (typeof mxRectangleShape !== 'undefined') {
                        mxCellRenderer.registerShape('note', mxRectangleShape);
                    }
                    
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å››è§’å½¢ã‚’rounded rectã¨ã—ã¦ã‚‚ç™»éŒ²
                    if (typeof mxRectangleShape !== 'undefined') {
                        mxCellRenderer.registerShape('rounded', mxRectangleShape);
                    }
                    
                } catch (error) {
                    console.error('ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ã‚¤ãƒ—ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // drawioã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ­£ç¢ºã«é©ç”¨ï¼ˆDraw.ioäº’æ›ï¼‰
            fixGraphStyles(graph) {
                // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å­˜åœ¨ç¢ºèª
                if (!graph || !graph.getModel) {
                    console.error('ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç„¡åŠ¹ã§ã™');
                    return;
                }
                
                const model = graph.getModel();
                const cells = model.cells;
                
                model.beginUpdate();
                try {
                    for (let cellId in cells) {
                        const cell = cells[cellId];
                        if (!cell || !cell.style) continue;
                        
                        // ã‚¹ã‚¿ã‚¤ãƒ«æ–‡å­—åˆ—ã‚’è§£æ
                        let style = cell.style;
                        
                        // Draw.ioäº’æ›ã®ã‚·ã‚§ã‚¤ãƒ—ãƒãƒƒãƒ”ãƒ³ã‚°
                        style = this.mapDrawioShapes(style);
                        
                        // ã‚¹ã‚¿ã‚¤ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è§£æã—ã¦é©ç”¨
                        const styleObj = this.parseStyleString(style);
                        
                        // Draw.ioäº’æ›ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´
                        this.adjustDrawioCompatibleStyle(styleObj, cell);
                        
                        // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å†æ§‹ç¯‰
                        const newStyle = this.rebuildStyleString(styleObj);
                        
                        // ã‚»ãƒ«ã«ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨ï¼ˆsetStyleãƒ¡ã‚½ãƒƒãƒ‰ãŒå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
                        if (typeof cell.setStyle === 'function') {
                            cell.setStyle(newStyle);
                        } else {
                            // setStyleãŒãªã„å ´åˆã¯ç›´æ¥styleãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®š
                            cell.style = newStyle;
                        }
                    }
                } finally {
                    model.endUpdate();
                }
                
                graph.refresh();
            }
            
            // Draw.ioã‚·ã‚§ã‚¤ãƒ—ãƒãƒƒãƒ”ãƒ³ã‚°
            mapDrawioShapes(style) {
                // shape=rhombusãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆã²ã—å½¢ï¼‰
                if (style.includes('rhombus')) {
                    console.log('ã²ã—å½¢ã‚·ã‚§ã‚¤ãƒ—ã‚’æ¤œå‡º:', style);
                }
                
                // shape=ellipseãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆä¸¸ï¼‰
                if (style.includes('ellipse')) {
                    console.log('æ¥•å††ã‚·ã‚§ã‚¤ãƒ—ã‚’æ¤œå‡º:', style);
                }
                
                // shape=documentãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªï¼ˆå¸³ç¥¨ï¼‰
                if (style.includes('document')) {
                    console.log('ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚·ã‚§ã‚¤ãƒ—ã‚’æ¤œå‡º:', style);
                }
                
                // cylinder3 -> cylinder
                style = style.replace(/shape=cylinder3/g, 'shape=cylinder');
                
                // ãã®ä»–ã®ã‚·ã‚§ã‚¤ãƒ—ãƒãƒƒãƒ”ãƒ³ã‚°
                style = style.replace(/shape=process/g, 'shape=rectangle');
                style = style.replace(/shape=rhombus/g, 'shape=rhombus');
                
                return style;
            }
            
            // ã‚¹ã‚¿ã‚¤ãƒ«æ–‡å­—åˆ—ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«è§£æ
            parseStyleString(style) {
                const styleObj = {};
                const pairs = style.split(';');
                
                pairs.forEach(pair => {
                    const [key, value] = pair.split('=');
                    if (key && value) {
                        styleObj[key.trim()] = value.trim();
                    }
                });
                
                return styleObj;
            }
            
            // Draw.ioäº’æ›ã®ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´
            adjustDrawioCompatibleStyle(styleObj, cell) {
                // ãƒ•ã‚©ãƒ³ãƒˆè¨­å®šã®èª¿æ•´ï¼ˆDraw.ioãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                if (!styleObj.fontFamily) {
                    styleObj.fontFamily = 'Helvetica';
                }
                
                if (!styleObj.fontSize) {
                    styleObj.fontSize = '12';
                }
                
                // ãƒ•ã‚©ãƒ³ãƒˆè‰²ã®èª¿æ•´
                if (styleObj.shape === 'ellipse' || styleObj.shape === 'cylinder') {
                    if (styleObj.fillColor === '#2196F3' && !styleObj.fontColor) {
                        styleObj.fontColor = '#ffffff';
                    }
                }
                
                if (!styleObj.fontColor) {
                    styleObj.fontColor = '#000000';
                }
                
                // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®èª¿æ•´ï¼ˆDraw.ioäº’æ›ï¼‰
                if (!styleObj.strokeWidth) {
                    styleObj.strokeWidth = '1';
                }
                
                if (!styleObj.strokeColor && styleObj.shape !== 'ellipse') {
                    styleObj.strokeColor = '#000000';
                }
                
                // ã‚·ã‚§ã‚¤ãƒ—åˆ¥ã®å¾®èª¿æ•´
                if (styleObj.shape === 'ellipse') {
                    // æ¥•å††å½¢ã®å ´åˆï¼ˆé–‹å§‹ãƒ»çµ‚äº†ãƒãƒ¼ãƒ‰ï¼‰
                    styleObj.aspect = 'fixed'; // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”å›ºå®š
                }
                
                if (styleObj.shape === 'cylinder') {
                    // ã‚·ãƒªãƒ³ãƒ€ãƒ¼å½¢çŠ¶ã®å ´åˆï¼ˆDBï¼‰
                    if (!styleObj.size) {
                        styleObj.size = '15'; // Draw.ioã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                    }
                }
                
                if (styleObj.shape === 'rhombus') {
                    // ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰å½¢çŠ¶ã®å ´åˆï¼ˆåˆ¤æ–­ï¼‰
                    styleObj.perimeter = 'rhombusPerimeter';
                }
                
                // è§’ä¸¸ã®èª¿æ•´ï¼ˆDraw.ioã¨ã®äº’æ›æ€§ï¼‰
                if (styleObj.shape === 'rectangle' && !styleObj.rounded) {
                    // ã‚¿ã‚¹ã‚¯ãƒœãƒƒã‚¯ã‚¹ã®å ´åˆã¯è»½ã„è§’ä¸¸ã‚’é©ç”¨
                    if (styleObj.fillColor === '#f5faff' || styleObj.fillColor === '#ffffff') {
                        styleObj.rounded = '1';
                        styleObj.arcSize = '10';
                    }
                }
                
                // ãƒ†ã‚­ã‚¹ãƒˆé…ç½®ã®èª¿æ•´
                if (!styleObj.align) {
                    styleObj.align = 'center';
                }
                if (!styleObj.verticalAlign) {
                    styleObj.verticalAlign = 'middle';
                }
            }
            
            // ã‚¹ã‚¿ã‚¤ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ–‡å­—åˆ—ã«å†æ§‹ç¯‰
            rebuildStyleString(styleObj) {
                return Object.entries(styleObj)
                    .filter(([key, value]) => key && value)
                    .map(([key, value]) => `${key}=${value}`)
                    .join(';');
            }
            
            // æ–°ã—ã„è¦ç´ ã‚’ã‚°ãƒ©ãƒ•ã«è¿½åŠ 
            addNewElementsToGraph(drawioCode) {
                if (!this.currentGraph) return;
                
                try {
                    // XMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ï¼ˆåŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                    const escapeXmlAttribute = (str) => {
                        if (!str) return str;
                        return str
                            .replace(/&(?!amp;|lt;|gt;|quot;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#x27;');
                    };
                    
                    // drawioã‚³ãƒ¼ãƒ‰ã®å±æ€§å€¤ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                    let escapedDrawioCode = drawioCode;
                    escapedDrawioCode = escapedDrawioCode.replace(/(\w+)="([^"]*)"/g, (match, attrName, attrValue) => {
                        if (attrValue.includes('&lt;') || attrValue.includes('&gt;') || 
                            attrValue.includes('&amp;') || attrValue.includes('&quot;')) {
                            return match;
                        }
                        if (attrValue.includes('<') || attrValue.includes('>') || 
                            attrValue.includes('&') || attrValue.includes('"')) {
                            const escaped = escapeXmlAttribute(attrValue);
                            return `${attrName}="${escaped}"`;
                        }
                        return match;
                    });
                    
                    // éƒ¨åˆ†çš„ãªXMLã‚’ãƒ‘ãƒ¼ã‚¹
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(escapedDrawioCode, 'text/xml');
                    
                    // mxCellã‚’æ¤œç´¢
                    const cells = doc.querySelectorAll('mxCell');
                    const model = this.currentGraph.getModel();
                    const parent = this.currentGraph.getDefaultParent();
                    
                    // ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°ã‚’é–‹å§‹
                    model.beginUpdate();
                    
                    try {
                        // ã¾ãšé ‚ç‚¹ã‚’å‡¦ç†
                        cells.forEach((cellElement) => {
                            const cellId = cellElement.getAttribute('id');
                            if (!cellId || this.parsedCells.has(cellId)) return;
                            
                            const vertex = cellElement.getAttribute('vertex') === '1';
                            if (!vertex) return;
                            
                            // æ–°ã—ã„ã‚»ãƒ«ã®å ´åˆã®ã¿è¿½åŠ 
                            this.parsedCells.add(cellId);
                            
                            const value = cellElement.getAttribute('value') || '';
                            const style = cellElement.getAttribute('style') || '';
                            const geometry = cellElement.querySelector('mxGeometry');
                            
                            if (geometry) {
                                const x = parseFloat(geometry.getAttribute('x') || '0');
                                const y = parseFloat(geometry.getAttribute('y') || '0');
                                const width = parseFloat(geometry.getAttribute('width') || '100');
                                const height = parseFloat(geometry.getAttribute('height') || '40');
                                
                                try {
                                    // é ‚ç‚¹ã‚’è¿½åŠ 
                                    const v = this.currentGraph.insertVertex(
                                        parent, cellId, value, x, y, width, height, 
                                        this.determineStyleFromDrawio(style)
                                    );
                                    // é ‚ç‚¹ã‚’ãƒãƒƒãƒ—ã«ä¿å­˜
                                    this.vertexMap.set(cellId, v);
                                    console.log('é ‚ç‚¹è¿½åŠ :', cellId, value);
                                } catch (e) {
                                    console.debug('é ‚ç‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼:', e);
                                }
                            }
                        });
                        
                        // æ¬¡ã«ã‚¨ãƒƒã‚¸ã‚’å‡¦ç†
                        cells.forEach((cellElement) => {
                            const cellId = cellElement.getAttribute('id');
                            if (!cellId || this.parsedCells.has(cellId)) return;
                            
                            const edge = cellElement.getAttribute('edge') === '1';
                            if (!edge) return;
                            
                            // æ–°ã—ã„ã‚»ãƒ«ã®å ´åˆã®ã¿è¿½åŠ 
                            this.parsedCells.add(cellId);
                            
                            const value = cellElement.getAttribute('value') || '';
                            const style = cellElement.getAttribute('style') || '';
                            const sourceId = cellElement.getAttribute('source');
                            const targetId = cellElement.getAttribute('target');
                            
                            // ã‚¨ãƒƒã‚¸ã®è¿½åŠ ã‚’è©¦è¡Œ
                            this.tryAddEdge(cellId, value, style, sourceId, targetId, cellElement);
                        });
                        
                        // ä¿ç•™ä¸­ã®ã‚¨ãƒƒã‚¸ã‚’å†åº¦è©¦è¡Œ
                        this.processPendingEdges();
                        
                    } finally {
                        // ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°ã‚’çµ‚äº†
                        model.endUpdate();
                    }
                    
                    // ã‚°ãƒ©ãƒ•ã‚’æ›´æ–°
                    this.currentGraph.refresh();
                    
                    // åˆå›è¡¨ç¤ºå®Œäº†æ™‚
                    if (!this.svgDisplayed && this.parsedCells.size > 0) {
                        requestAnimationFrame(() => {
                            this.elements.flowDiagram.classList.remove('svg-processing');
                            this.elements.flowDiagram.classList.add('svg-ready');
                            this.svgDisplayed = true;
                        });
                    }
                    
                } catch (error) {
                    console.debug('è¦ç´ è¿½åŠ ã‚¨ãƒ©ãƒ¼:', error);
                }
            }
            
            // drawioã‚¹ã‚¿ã‚¤ãƒ«ã‹ã‚‰MXGraphã‚¹ã‚¿ã‚¤ãƒ«ã‚’åˆ¤å®š
            determineStyleFromDrawio(drawioStyle) {
                // é–‹å§‹ãƒ»çµ‚äº†ã®åˆ¤å®šã‚’æ”¹å–„
                if (drawioStyle.includes('ellipse') || drawioStyle.includes('shape=ellipse')) {
                    return 'startEnd';
                }
                if (drawioStyle.includes('rhombus') || drawioStyle.includes('shape=rhombus')) {
                    return 'decision';
                }
                if (drawioStyle.includes('cylinder') || drawioStyle.includes('shape=cylinder3')) {
                    return 'database';
                }
                if (drawioStyle.includes('document') || drawioStyle.includes('shape=document')) {
                    return 'document';
                }
                if (drawioStyle.includes('rounded=1')) {
                    return 'task';
                }
                return 'task'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
            }
            
            // ã‚¨ãƒƒã‚¸ã®è¿½åŠ ã‚’è©¦è¡Œ
            tryAddEdge(cellId, value, style, sourceId, targetId, cellElement) {
                const source = this.vertexMap.get(sourceId);
                const target = this.vertexMap.get(targetId);
                
                if (source && target) {
                    // source/targetãŒä¸¡æ–¹è¦‹ã¤ã‹ã£ãŸå ´åˆã¯ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ 
                    try {
                        const parent = this.currentGraph.getDefaultParent();
                        const edgeStyle = this.determineEdgeStyle(style);
                        
                        // mxGeometryã‹ã‚‰ãƒã‚¤ãƒ³ãƒˆæƒ…å ±ã‚’å–å¾—
                        const geometry = cellElement.querySelector('mxGeometry');
                        const points = [];
                        if (geometry) {
                            const pointElements = geometry.querySelectorAll('mxPoint');
                            pointElements.forEach(point => {
                                const x = parseFloat(point.getAttribute('x') || '0');
                                const y = parseFloat(point.getAttribute('y') || '0');
                                points.push(new mxPoint(x, y));
                            });
                        }
                        
                        // ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ 
                        const edge = this.currentGraph.insertEdge(
                            parent, cellId, value, source, target, edgeStyle
                        );
                        
                        // ãƒã‚¤ãƒ³ãƒˆãŒã‚ã‚‹å ´åˆã¯è¨­å®š
                        if (points.length > 0 && edge.geometry) {
                            edge.geometry.points = points;
                        }
                        
                        console.log('ã‚¨ãƒƒã‚¸è¿½åŠ :', cellId, sourceId, '->', targetId);
                    } catch (e) {
                        console.debug('ã‚¨ãƒƒã‚¸è¿½åŠ ã‚¨ãƒ©ãƒ¼:', e);
                    }
                } else {
                    // source/targetãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¿ç•™
                    this.pendingEdges.push({
                        cellId, value, style, sourceId, targetId, cellElement
                    });
                }
            }
            
            // ä¿ç•™ä¸­ã®ã‚¨ãƒƒã‚¸ã‚’å‡¦ç†
            processPendingEdges() {
                const remainingEdges = [];
                
                this.pendingEdges.forEach(edge => {
                    const source = this.vertexMap.get(edge.sourceId);
                    const target = this.vertexMap.get(edge.targetId);
                    
                    if (source && target) {
                        // ä»Šå›ã¯è¿½åŠ ã§ãã‚‹
                        this.tryAddEdge(edge.cellId, edge.value, edge.style, 
                                       edge.sourceId, edge.targetId, edge.cellElement);
                    } else {
                        // ã¾ã è¿½åŠ ã§ããªã„
                        remainingEdges.push(edge);
                    }
                });
                
                this.pendingEdges = remainingEdges;
            }
            
            // ã‚¨ãƒƒã‚¸ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ±ºå®š
            determineEdgeStyle(drawioStyle) {
                // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒƒã‚¸ã‚¹ã‚¿ã‚¤ãƒ«
                let style = 'edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;';
                
                // è‰²ã‚’åˆ¤å®š
                if (drawioStyle.includes('#1E88E5')) {
                    style += 'strokeColor=#1E88E5;';
                } else {
                    style += 'strokeColor=#333333;';
                }
                
                style += 'strokeWidth=1.5;endArrow=classic;endFill=1;';
                
                return style;
            }
            
            // éƒ¨åˆ†çš„ãªdrawioã‚³ãƒ¼ãƒ‰ã‚’ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
            showPartialDrawioAsText(drawioCode) {
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»ä¸­ã¯ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºã—ãªã„
                console.log('éƒ¨åˆ†çš„ãªdrawioã‚³ãƒ¼ãƒ‰:', drawioCode.length, 'æ–‡å­—');
                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æç”»ã‚’ç¶™ç¶š
            }
            
            // MXGraphã‚¨ãƒ©ãƒ¼æ™‚ã®è¡¨ç¤º
            showMXGraphError(drawioCode, error) {
                console.error('MXGraphã‚¨ãƒ©ãƒ¼è¡¨ç¤º:', error.message);
                // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ç©ºã®ã‚°ãƒ©ãƒ•ã‚’è¡¨ç¤º
                this.elements.flowDiagram.innerHTML = '<div id="mxgraph-container" style="width: 100%; height: 400px; background: white; overflow: auto;"></div>';
                const container = document.getElementById('mxgraph-container');
                if (container && typeof mxGraph !== 'undefined') {
                    try {
                        const graph = new mxGraph(container);
                        graph.setEnabled(false);
                        this.setupGraphStyles(graph);
                        
                        // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                        const parent = graph.getDefaultParent();
                        graph.getModel().beginUpdate();
                        try {
                            graph.insertVertex(parent, null, 'MXGraphã‚¨ãƒ©ãƒ¼: ' + error.message, 20, 20, 300, 60, 
                                'fillColor=#ffcccc;strokeColor=#cc0000;fontColor=#cc0000');
                        } finally {
                            graph.getModel().endUpdate();
                        }
                    } catch (e) {
                        console.error('ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚‚å¤±æ•—:', e);
                    }
                }
            }
            
            // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å†èª­ã¿è¾¼ã¿
            loadMXGraphAndRetry(drawioCode) {
                console.log('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å†èª­ã¿è¾¼ã¿ã‚’è©¦è¡Œ');
                // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¿ã‚°ã‚’å‹•çš„ã«è¿½åŠ 
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = 'https://jgraph.github.io/mxgraph/javascript/mxClient.js';
                script.onload = () => {
                    console.log('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªå†èª­ã¿è¾¼ã¿å®Œäº†');
                    this.updateFlowDiagram(drawioCode);
                };
                script.onerror = () => {
                    console.error('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—');
                    this.showDrawioAsText(drawioCode);
                };
                document.head.appendChild(script);
            }

            // å¾“æ¥ã®SVGæŠ½å‡ºï¼ˆãƒãƒƒãƒãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
            extractAndUpdateSVG(content) {
                console.log('drawioæŠ½å‡ºé–‹å§‹, ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é•·:', content ? content.length : 0);
                const svgMatch = content.match(/<\?xml[\s\S]*?<\/mxfile>|<mxfile[\s\S]*?<\/mxfile>/);
                if (svgMatch) {
                    const svgCode = svgMatch[0];
                    console.log('drawioæŠ½å‡ºæˆåŠŸ, drawioé•·:', svgCode.length);
                    
                    // ãƒãƒƒãƒãƒ¢ãƒ¼ãƒ‰ã§ã‚‚accumulatedSvgCodeã«ä¿å­˜ï¼ˆã‚³ãƒ”ãƒ¼æ©Ÿèƒ½ã®ãŸã‚ï¼‰
                    this.accumulatedSvgCode = svgCode;
                    console.log('accumulatedSvgCodeã«ä¿å­˜ã—ã¾ã—ãŸ');
                    
                    this.displaySVGCode(svgCode);
                    this.forceScroll(this.elements.svgCode);
                    this.updateStatus('code', 'SVGæŠ½å‡ºæ¸ˆã¿');
                    
                    // ãƒ•ãƒ­ãƒ¼å›³ã®æ›´æ–°
                    console.log('===== ãƒ•ãƒ­ãƒ¼å›³æ›´æ–°ã‚’å‘¼ã³å‡ºã— =====');
                    console.log('SVGã‚³ãƒ¼ãƒ‰ã®æœ€åˆã®500æ–‡å­—:', svgCode.substring(0, 500));
                    this.updateFlowDiagram(svgCode);
                } else {
                    console.warn('drawioã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                    console.log('ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹ã®æœ€åˆã®500æ–‡å­—:', content.substring(0, 500));
                    console.log('ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹ã®æœ€å¾Œã®500æ–‡å­—:', content.substring(content.length - 500));
                    
                    // åˆ¥ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚‚æ¢ã™
                    const alternativeMatch = content.match(/<mxfile[\s\S]*?<\/mxfile>/);
                    if (alternativeMatch) {
                        console.log('ä»£æ›¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã§drawioã‚³ãƒ¼ãƒ‰ã‚’ç™ºè¦‹ï¼');
                        const svgCode = alternativeMatch[0];
                        this.accumulatedSvgCode = svgCode;
                        this.displaySVGCode(svgCode);
                        this.updateFlowDiagram(svgCode);
                        return;
                    }
                    
                    this.updateStatus('code', 'drawioãªã—');
                    this.updateStatus('diagram', 'drawioãªã—');
                    
                    // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
                    this.showError('drawioã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                }
            }

            // MXGraphã®åŸºæœ¬çš„ãªå‹•ä½œãƒ†ã‚¹ãƒˆ
            testBasicMXGraph() {
                console.log('=== MXGraphåŸºæœ¬ãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
                
                try {
                    // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å­˜åœ¨ç¢ºèª
                    console.log('mxGraphå®šç¾©:', typeof mxGraph !== 'undefined');
                    console.log('mxUtilså®šç¾©:', typeof mxUtils !== 'undefined');
                    console.log('mxConstantså®šç¾©:', typeof mxConstants !== 'undefined');
                    console.log('mxCellRendererå®šç¾©:', typeof mxCellRenderer !== 'undefined');
                    
                    if (typeof mxGraph === 'undefined') {
                        console.error('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                        return false;
                    }
                    
                    // ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
                    this.elements.flowDiagram.innerHTML = '<div id="test-container" style="width: 100%; height: 500px; background: #f0f0f0;"></div>';
                    const container = document.getElementById('test-container');
                    
                    if (!container) {
                        console.error('ãƒ†ã‚¹ãƒˆã‚³ãƒ³ãƒ†ãƒŠã®ä½œæˆã«å¤±æ•—');
                        return false;
                    }
                    
                    // MXGraphã‚’åˆæœŸåŒ–
                    const graph = new mxGraph(container);
                    graph.setEnabled(false);
                    
                    const parent = graph.getDefaultParent();
                    graph.getModel().beginUpdate();
                    
                    try {
                        // ç°¡å˜ãªè¦ç´ ã‚’è¿½åŠ 
                        const v1 = graph.insertVertex(parent, null, 'ãƒ†ã‚¹ãƒˆé–‹å§‹', 20, 20, 80, 30, 
                            'fillColor=#2196F3;strokeColor=#0D47A1;fontColor=#ffffff;shape=ellipse');
                        const v2 = graph.insertVertex(parent, null, 'ã‚¿ã‚¹ã‚¯1', 150, 20, 100, 40,
                            'fillColor=#f5faff;strokeColor=#2196F3;fontColor=#000000');
                        const v3 = graph.insertVertex(parent, null, 'DB', 300, 20, 80, 60,
                            'shape=cylinder;fillColor=#2196F3;strokeColor=#0D47A1;fontColor=#ffffff');
                        
                        graph.insertEdge(parent, null, '', v1, v2);
                        graph.insertEdge(parent, null, '', v2, v3);
                        
                        console.log('ãƒ†ã‚¹ãƒˆè¦ç´ ã®è¿½åŠ æˆåŠŸ');
                    } finally {
                        graph.getModel().endUpdate();
                    }
                    
                    // ã‚³ãƒ³ãƒ†ãƒŠã®å†…å®¹ã‚’ç¢ºèª
                    const svg = container.querySelector('svg');
                    if (svg) {
                        console.log('SVGè¦ç´ ãŒä½œæˆã•ã‚Œã¾ã—ãŸ');
                        console.log('SVGã‚µã‚¤ã‚º:', svg.getAttribute('width'), 'x', svg.getAttribute('height'));
                    } else {
                        console.error('SVGè¦ç´ ãŒä½œæˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    }
                    
                    console.log('=== MXGraphåŸºæœ¬ãƒ†ã‚¹ãƒˆå®Œäº† ===');
                    return true;
                    
                } catch (error) {
                    console.error('MXGraphåŸºæœ¬ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    console.error('ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯:', error.stack);
                    return false;
                }
            }

            updateFlowDiagram(drawioCode) {
                console.log('=== updateFlowDiagramé–‹å§‹ ===');
                console.log('drawioã‚³ãƒ¼ãƒ‰é•·:', drawioCode ? drawioCode.length : 0);
                console.log('æœ€åˆã®200æ–‡å­—:', drawioCode ? drawioCode.substring(0, 200) : 'null');
                console.log('mxGraphåˆ©ç”¨å¯èƒ½:', typeof mxGraph !== 'undefined');
                console.log('flowDiagramè¦ç´ :', this.elements.flowDiagram);
                
                // ãƒ‡ãƒãƒƒã‚°: ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã®ç¾åœ¨ã®å†…å®¹ã‚’ç¢ºèª
                console.log('ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã®å­è¦ç´ æ•°:', this.elements.flowDiagram.children.length);
                console.log('ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã®innerHTMLé•·:', this.elements.flowDiagram.innerHTML.length);
                
                // ä»¥å‰ã®ã‚¹ã‚­ãƒƒãƒ—å‡¦ç†ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°ã®ãŸã‚ï¼‰
                /*
                const existingGraph = document.getElementById('mxgraph-container');
                if (existingGraph && existingGraph.children.length > 0) {
                    console.log('ãƒ•ãƒ­ãƒ¼å›³ãŒæ—¢ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€æ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™');
                    this.updateStatus('diagram', 'è¡¨ç¤ºæ¸ˆã¿');
                    return;
                }
                */
                
                // ç›´æ¥æç”»ã‚’å®Ÿè¡Œ
                console.log('drawioæç”»ã‚’é–‹å§‹...');
                this._performActualDrawing(drawioCode);
            }
            
            _performActualDrawing(drawioCode) {
                console.log('=== å®Ÿéš›ã®drawioæç”»é–‹å§‹ ===');
                
                try {
                    // XMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°
                    const escapeXmlAttribute = (str) => {
                        if (!str) return str;
                        // å±æ€§å€¤å†…ã®ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                        return str
                            .replace(/&(?!amp;|lt;|gt;|quot;|#x[0-9a-fA-F]+;|#[0-9]+;)/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#x27;');
                    };
                    
                    // drawioã‚³ãƒ¼ãƒ‰ã®å±æ€§å€¤ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                    // å±æ€§å€¤å†…ã® < > & " ' ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã™ã‚‹
                    let escapedDrawioCode = drawioCode;
                    
                    // å±æ€§å€¤å†…ã®æœªã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ–‡å­—ã‚’æ¤œå‡ºã—ã¦ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                    escapedDrawioCode = escapedDrawioCode.replace(/(\w+)="([^"]*)"/g, (match, attrName, attrValue) => {
                        // æ—¢ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¯é™¤å¤–
                        if (attrValue.includes('&lt;') || attrValue.includes('&gt;') || 
                            attrValue.includes('&amp;') || attrValue.includes('&quot;')) {
                            return match;
                        }
                        // æœªã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã® < > & ã‚’å«ã‚€å ´åˆã¯ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                        if (attrValue.includes('<') || attrValue.includes('>') || 
                            attrValue.includes('&') || attrValue.includes('"')) {
                            const escaped = escapeXmlAttribute(attrValue);
                            return `${attrName}="${escaped}"`;
                        }
                        return match;
                    });
                    
                    // drawioã‚³ãƒ¼ãƒ‰ã®å¦¥å½“æ€§ç¢ºèª
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(escapedDrawioCode, 'text/xml');
                    const parseError = doc.querySelector('parsererror');
                    
                    if (parseError) {
                        console.error('XMLãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:', parseError.textContent);
                        return;
                    }
                    console.log('XMLè§£ææˆåŠŸ');

                    // ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã‚’å‡¦ç†ä¸­çŠ¶æ…‹ã«ã™ã‚‹
                    this.elements.flowDiagram.classList.add('svg-processing');
                    this.elements.flowDiagram.classList.remove('svg-ready');
                    
                    // MXGraphã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
                    console.log('MXGraphã‚³ãƒ³ãƒ†ãƒŠä½œæˆä¸­...');
                    console.log('ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã®ã‚µã‚¤ã‚º:', this.elements.flowDiagram.offsetWidth, 'x', this.elements.flowDiagram.offsetHeight);
                    
                    this.elements.flowDiagram.innerHTML = '<div id="mxgraph-container" style="width: 100%; height: 100%; min-height: 600px; background: white; overflow: auto; position: relative;"></div>';
                    const container = document.getElementById('mxgraph-container');
                    
                    if (!container) {
                        console.error('ã‚³ãƒ³ãƒ†ãƒŠã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                        return;
                    }
                    console.log('ã‚³ãƒ³ãƒ†ãƒŠä½œæˆæˆåŠŸ');
                    
                    // MXGraphã‚’åˆæœŸåŒ–ã—ã¦drawioã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    console.log('mxGraphåˆ©ç”¨å¯èƒ½ï¼ˆå†…éƒ¨ï¼‰:', typeof mxGraph !== 'undefined');
                    if (typeof mxGraph !== 'undefined') {
                        console.log('MXGraphã®åˆæœŸåŒ–ã‚’é–‹å§‹ã—ã¾ã™');
                        try {
                            // ã‚°ãƒ©ãƒ•ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
                            const graph = new mxGraph(container);
                            graph.setEnabled(false); // ç·¨é›†ã‚’ç„¡åŠ¹åŒ–ï¼ˆè¡¨ç¤ºã®ã¿ï¼‰
                            
                            // èƒŒæ™¯è‰²ã‚’è¨­å®š
                            graph.setBackgroundImage(null);
                            const bg = graph.getView().getBackgroundPane();
                            if (bg) {
                                bg.style.backgroundColor = '#ffffff';
                            }
                            
                            // ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
                            this.setupGraphStyles(graph);
                            
                            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ†ã‚¹ãƒˆè¦ç´ ã¯å‰Šé™¤ï¼ˆå®Ÿéš›ã®ãƒ•ãƒ­ãƒ¼å›³ã®ã¿è¡¨ç¤ºï¼‰
                            
                            // drawio XMLã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
                            console.log('drawio XMLãƒ‡ã‚³ãƒ¼ãƒ‰é–‹å§‹');
                            console.log('doc.documentElement:', doc.documentElement);
                            console.log('doc.documentElement.tagName:', doc.documentElement.tagName);
                            const codec = new mxCodec();
                            const diagramNode = doc.documentElement.querySelector('diagram');
                            console.log('diagramNodeå­˜åœ¨:', !!diagramNode);
                            console.log('docå…¨ä½“ï¼ˆæœ€åˆã®500æ–‡å­—ï¼‰:', new XMLSerializer().serializeToString(doc).substring(0, 500));
                            
                            if (diagramNode) {
                                // Base64ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆdrawioãƒ•ã‚¡ã‚¤ãƒ«ã¯é€šå¸¸åœ§ç¸®ã•ã‚Œã¦ã„ã‚‹ï¼‰
                                console.log('diagramã‚³ãƒ³ãƒ†ãƒ³ãƒ„é•·:', diagramNode.textContent ? diagramNode.textContent.length : 0);
                                
                                // diagramãƒãƒ¼ãƒ‰å†…ã«ç›´æ¥mxGraphModelãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨
                                const innerGraphModel = diagramNode.querySelector('mxGraphModel');
                                if (innerGraphModel) {
                                    console.log('diagramå†…ã«ç›´æ¥mxGraphModelã‚’ç™ºè¦‹ã€‚åœ§ç¸®ã•ã‚Œã¦ã„ãªã„drawioãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚');
                                    console.log('innerGraphModel:', innerGraphModel);
                                    console.log('innerGraphModel childrenæ•°:', innerGraphModel.children.length);
                                    try {
                                        codec.decode(innerGraphModel, graph.getModel());
                                        console.log('ç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†');
                                        const cellCount = Object.keys(graph.getModel().cells).length;
                                        console.log('ãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œã®ã‚»ãƒ«æ•°:', cellCount);
                                    } catch (decodeError) {
                                        console.error('ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', decodeError);
                                    }
                                } else {
                                    // åœ§ç¸®ã•ã‚Œã¦ã„ã‚‹å ´åˆã®å‡¦ç†
                                    try {
                                        const compressed = diagramNode.textContent || diagramNode.innerHTML;
                                        console.log('åœ§ç¸®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ä¸­...');
                                        
                                        // graph.decompressã®ä»£æ›¿å‡¦ç†
                                        let decompressed;
                                        if (typeof graph.decompress === 'function') {
                                            decompressed = graph.decompress(compressed);
                                        } else if (typeof mxUtils !== 'undefined' && typeof mxUtils.decompress === 'function') {
                                            decompressed = mxUtils.decompress(compressed);
                                        } else {
                                            console.log('ãƒ‡ã‚³ãƒ³ãƒ—ãƒ¬ã‚¹æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚Base64ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚’è©¦è¡Œ...');
                                            try {
                                                decompressed = atob(compressed);
                                            } catch (e) {
                                                console.log('Base64ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚‚å¤±æ•—ã€ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨');
                                                decompressed = compressed;
                                            }
                                        }
                                    
                                    console.log('ãƒ‡ã‚³ãƒ¼ãƒ‰æˆåŠŸã€XMLè§£æä¸­...');
                                    // mxUtilsãŒåˆ©ç”¨ã§ããªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                                    if (typeof mxUtils !== 'undefined' && typeof mxUtils.parseXml === 'function') {
                                        const xmlDoc = mxUtils.parseXml(decompressed);
                                        codec.decode(xmlDoc.documentElement, graph.getModel());
                                    } else {
                                        // DOMParserã‚’ä½¿ç”¨
                                        const parser = new DOMParser();
                                        const xmlDoc = parser.parseFromString(decompressed, 'text/xml');
                                        const mxGraphModel = xmlDoc.querySelector('mxGraphModel');
                                        if (mxGraphModel) {
                                            codec.decode(mxGraphModel, graph.getModel());
                                        }
                                    }
                                    console.log('ã‚°ãƒ©ãƒ•ãƒ¢ãƒ‡ãƒ«ã¸ã®ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†');
                                    } catch (e) {
                                        console.log('åœ§ç¸®ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', e.message);
                                        // åœ§ç¸®ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç›´æ¥ãƒ‘ãƒ¼ã‚¹
                                        const mxGraphModel = doc.querySelector('mxGraphModel');
                                        console.log('mxGraphModelå­˜åœ¨:', !!mxGraphModel);
                                        if (mxGraphModel) {
                                            console.log('ç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œ');
                                            codec.decode(mxGraphModel, graph.getModel());
                                            console.log('ç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†');
                                        } else {
                                            console.error('mxGraphModelè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                                        }
                                    }
                                }
                            } else {
                                // diagramNodeãŒãªã„å ´åˆã‚‚ç›´æ¥mxGraphModelã‚’æ¢ã™
                                const mxGraphModel = doc.querySelector('mxGraphModel');
                                console.log('mxGraphModelå­˜åœ¨ï¼ˆç›´æ¥ï¼‰:', !!mxGraphModel);
                                if (mxGraphModel) {
                                    console.log('ç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰å®Ÿè¡Œï¼ˆdiagramãªã—ï¼‰');
                                    codec.decode(mxGraphModel, graph.getModel());
                                    console.log('ç›´æ¥ãƒ‡ã‚³ãƒ¼ãƒ‰å®Œäº†ï¼ˆdiagramãªã—ï¼‰');
                                }
                            }
                            
                            // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¿®æ­£ï¼ˆdrawioã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ãŒæ­£ã—ãé©ç”¨ã•ã‚Œã‚‹ã‚ˆã†ã«ï¼‰
                            console.log('ã‚¹ã‚¿ã‚¤ãƒ«ä¿®æ­£å‰ã®ã‚»ãƒ«æ•°:', Object.keys(graph.getModel().cells).length);
                            
                            // ã‚·ã‚§ã‚¤ãƒ—ã®çµ±è¨ˆã‚’å–ã‚‹
                            const shapeStats = {};
                            const cells = graph.getModel().cells;
                            let swimlaneCount = 0;
                            let groupCount = 0;
                            
                            for (let id in cells) {
                                const cell = cells[id];
                                if (cell && cell.style) {
                                    // shape=xxxã®å½¢å¼ã‚’æ¤œå‡º
                                    const shapeMatch = cell.style.match(/shape=(\w+)/);
                                    if (shapeMatch) {
                                        const shapeName = shapeMatch[1];
                                        shapeStats[shapeName] = (shapeStats[shapeName] || 0) + 1;
                                        if (shapeName === 'document') {
                                            console.log(`Document shape found: id=${id}, value=${cell.value}, geometry=`, cell.geometry);
                                        }
                                    }
                                    
                                    // swimlaneã¨groupã‚’ç‰¹åˆ¥ã«æ¤œå‡º
                                    if (cell.style.includes('swimlane')) {
                                        swimlaneCount++;
                                        console.log(`Swimlane found: id=${id}, value=${cell.value}, parent=${cell.parent ? cell.parent.id : 'none'}`);
                                    }
                                    if (cell.style.includes('group')) {
                                        groupCount++;
                                        console.log(`Group found: id=${id}, value=${cell.value}`);
                                    }
                                }
                            }
                            console.log('æ¤œå‡ºã•ã‚ŒãŸã‚·ã‚§ã‚¤ãƒ—:', shapeStats);
                            console.log(`ã‚¹ã‚¤ãƒ ãƒ¬ãƒ¼ãƒ³æ•°: ${swimlaneCount}, ã‚°ãƒ«ãƒ¼ãƒ—æ•°: ${groupCount}`);
                            
                            try {
                                this.fixGraphStyles(graph);
                                console.log('ã‚¹ã‚¿ã‚¤ãƒ«ä¿®æ­£å®Œäº†');
                            } catch (styleError) {
                                console.error('ã‚¹ã‚¿ã‚¤ãƒ«ä¿®æ­£ã‚¨ãƒ©ãƒ¼:', styleError);
                                console.log('ã‚¹ã‚¿ã‚¤ãƒ«ä¿®æ­£ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦ç¶šè¡Œ');
                            }
                            
                            // ã‚°ãƒ©ãƒ•ã‚’ä¸­å¤®ã«é…ç½®
                            console.log('ã‚°ãƒ©ãƒ•ã‚’ä¸­å¤®ã«é…ç½®ä¸­...');
                            
                            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã®ã¡ã‚‰ã¤ãã‚’é˜²ããŸã‚ã€èª¿æ•´ä¸­ã¯éè¡¨ç¤º
                            container.style.visibility = 'hidden';
                            
                            // ãƒ•ãƒ­ãƒ¼å›³ã‚’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«åˆã‚ã›ã¦ãƒ•ã‚£ãƒƒãƒˆ
                            try {
                                // ã¾ãšå…¨ä½“ã‚’è¡¨ç¤ºã§ãã‚‹ã‚ˆã†ã«ãƒ•ã‚£ãƒƒãƒˆ
                                graph.fit();
                                console.log('graph.fit()å®Ÿè¡Œå®Œäº†');
                                
                                // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å¢ƒç•Œã‚’å–å¾—ã—ã¦ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚ºã‚’èª¿æ•´
                                const bounds = graph.getGraphBounds();
                                if (bounds) {
                                    const padding = 20; // ä½™ç™½
                                    const contentWidth = Math.min(bounds.width + (padding * 2), this.elements.flowDiagram.clientWidth - 10); // è¦ªè¦ç´ å¹…ã‚’è¶…ãˆãªã„
                                    const contentHeight = Math.max(bounds.height + (padding * 2), 400); // æœ€å°é«˜ã•400px
                                    
                                    console.log(`ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚µã‚¤ã‚º: ${contentWidth}x${contentHeight}`);
                                    
                                    // ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’ä¸€åº¦ã«è¨­å®šï¼ˆã¡ã‚‰ã¤ãé˜²æ­¢ï¼‰
                                    requestAnimationFrame(() => {
                                        container.style.width = `${contentWidth}px`;
                                        container.style.height = `${contentHeight}px`;
                                        container.style.overflow = 'hidden'; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’éè¡¨ç¤º
                                        
                                        // ã‚°ãƒ©ãƒ•ã‚’å†èª¿æ•´
                                        graph.sizeDidChange();
                                        graph.center(true, true);
                                        
                                        // èª¿æ•´å®Œäº†å¾Œã«è¡¨ç¤º
                                        container.style.visibility = 'visible';
                                    });
                                } else {
                                    container.style.visibility = 'visible';
                                }
                            } catch (e) {
                                console.log('ãƒ•ã‚£ãƒƒãƒˆã‚¨ãƒ©ãƒ¼:', e.message);
                                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šæ¨™æº–ã‚µã‚¤ã‚ºã§ä¸­å¤®é…ç½®
                                graph.center(true, true);
                                container.style.visibility = 'visible';
                                console.log('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¸­å¤®é…ç½®å®Œäº†');
                            }
                            
                            // ã‚»ãƒ«ã®æ•°ã‚’ç¢ºèªï¼ˆcellsã¯æ—¢ã«å®£è¨€ã•ã‚Œã¦ã„ã‚‹ã®ã§å†åˆ©ç”¨ï¼‰
                            let vertexCount = 0;
                            let edgeCount = 0;
                            const bounds = [];
                            
                            for (let id in cells) {
                                const cell = cells[id];
                                if (cell && cell.vertex) {
                                    vertexCount++;
                                    const geo = cell.geometry;
                                    if (geo) {
                                        bounds.push({
                                            id: cell.id,
                                            value: cell.value,
                                            x: geo.x,
                                            y: geo.y,
                                            width: geo.width,
                                            height: geo.height
                                        });
                                    }
                                }
                                if (cell && cell.edge) edgeCount++;
                            }
                            console.log(`ã‚°ãƒ©ãƒ•å†…å®¹: é ‚ç‚¹æ•°=${vertexCount}, ã‚¨ãƒƒã‚¸æ•°=${edgeCount}`);
                            console.log('æœ€åˆã®5ã¤ã®è¦ç´ ã®ä½ç½®:', bounds.slice(0, 5));
                            
                            // ã‚»ãƒ«ãŒå°‘ãªã„å ´åˆã¯è­¦å‘Š
                            if (vertexCount === 0 && edgeCount === 0) {
                                console.error('è­¦å‘Š: ã‚°ãƒ©ãƒ•ã«è¦ç´ ãŒ1ã¤ã‚‚ã‚ã‚Šã¾ã›ã‚“ï¼');
                                // ãƒ†ã‚¹ãƒˆè¦ç´ ã‚’è¿½åŠ 
                                const parent = graph.getDefaultParent();
                                graph.getModel().beginUpdate();
                                try {
                                    graph.insertVertex(parent, null, 'ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ãƒ•ãƒ­ãƒ¼å›³ãŒè¡¨ç¤ºã•ã‚Œã¾ã›ã‚“', 20, 20, 300, 60,
                                        'fillColor=#ffcccc;strokeColor=#cc0000;fontColor=#cc0000');
                                } finally {
                                    graph.getModel().endUpdate();
                                }
                            }
                            
                            // ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’ç¢ºèª
                            // containerå¤‰æ•°ã¯æ—¢ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§å†å®šç¾©ã—ãªã„
                            if (container) {
                                const rect = container.getBoundingClientRect();
                                console.log(`ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚º: width=${rect.width}, height=${rect.height}`);
                                console.log(`ã‚³ãƒ³ãƒ†ãƒŠè¡¨ç¤ºçŠ¶æ…‹: display=${window.getComputedStyle(container).display}`);
                            }
                            
                            // ã‚°ãƒ©ãƒ•ã®ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã‚’ç¢ºèª
                            const view = graph.getView();
                            const scale = view.getScale();
                            const translate = view.getTranslate();
                            console.log(`ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼: scale=${scale}, translate=(${translate.x}, ${translate.y})`);
                            
                            // å¼·åˆ¶çš„ã«å†æç”»ã‚’è¡Œã†
                            console.log('å¼·åˆ¶å†æç”»ã‚’å®Ÿè¡Œä¸­...');
                            graph.refresh();
                            graph.sizeDidChange();
                            
                            // ã‚°ãƒ©ãƒ•ã®SVGè¦ç´ ã‚’ç›´æ¥ç¢ºèª
                            const svg = container.querySelector('svg');
                            if (svg) {
                                console.log('SVGè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ');
                                console.log(`SVGã‚µã‚¤ã‚º: width=${svg.getAttribute('width')}, height=${svg.getAttribute('height')}`);
                                const gElements = svg.querySelectorAll('g');
                                console.log(`gè¦ç´ ã®æ•°: ${gElements.length}`);
                                
                                // SVGãŒéš ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€å¼·åˆ¶çš„ã«è¡¨ç¤º
                                svg.style.display = 'block';
                                svg.style.visibility = 'visible';
                                svg.style.opacity = '1';
                                svg.style.position = 'relative';
                                svg.style.zIndex = '1';
                                
                                // ã‚³ãƒ³ãƒ†ãƒŠã‚‚ç¢ºå®Ÿã«è¡¨ç¤º
                                container.style.display = 'block';
                                container.style.visibility = 'visible';
                                container.style.opacity = '1';
                                
                                // SVGå†…ã®ã™ã¹ã¦ã®ãƒ‘ã‚¹ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º
                                const paths = svg.querySelectorAll('path, text, rect, ellipse, polygon');
                                console.log(`SVGå†…ã®æç”»è¦ç´ æ•°: ${paths.length}`);
                                paths.forEach((el, idx) => {
                                    if (idx < 5) {
                                        console.log(`è¦ç´ ${idx}: ${el.tagName}, style: ${el.getAttribute('style')}`);
                                    }
                                });
                                
                                // ãƒ‡ãƒãƒƒã‚°ãƒ†ã‚­ã‚¹ãƒˆã¯å‰Šé™¤ï¼ˆå®Ÿéš›ã®ãƒ•ãƒ­ãƒ¼å›³ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ï¼‰
                            } else {
                                console.error('SVGè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                                
                                // SVGãŒä½œæˆã•ã‚Œã¦ã„ãªã„å ´åˆã€ã‚³ãƒ³ãƒ†ãƒŠã®å­è¦ç´ ã‚’ç¢ºèª
                                console.log('ã‚³ãƒ³ãƒ†ãƒŠã®å­è¦ç´ æ•°:', container.children.length);
                                for (let i = 0; i < container.children.length; i++) {
                                    console.log(`å­è¦ç´ ${i}: ${container.children[i].tagName}, class: ${container.children[i].className}`);
                                }
                            }
                            
                            // è¡¨ç¤ºå®Œäº†
                            requestAnimationFrame(() => {
                                this.elements.flowDiagram.classList.remove('svg-processing');
                                this.elements.flowDiagram.classList.add('svg-ready');
                                console.log('è¡¨ç¤ºçŠ¶æ…‹æ›´æ–°å®Œäº†');
                                
                                // ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢è‡ªä½“ã®è¡¨ç¤ºã‚‚ç¢ºèª
                                const flowDiagramStyle = window.getComputedStyle(this.elements.flowDiagram);
                                console.log('ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã®è¡¨ç¤ºçŠ¶æ…‹:');
                                console.log('  display:', flowDiagramStyle.display);
                                console.log('  visibility:', flowDiagramStyle.visibility);
                                console.log('  opacity:', flowDiagramStyle.opacity);
                                console.log('  height:', flowDiagramStyle.height);
                            });
                            
                            this.updateStatus('diagram', 'æç”»å®Œäº†');
                            console.log('=== MXGraphãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Œäº† ===');
                            
                        } catch (mxError) {
                            console.error('MXGraphãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚¨ãƒ©ãƒ¼:', mxError);
                            console.error('ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯:', mxError.stack);
                            // ã‚¨ãƒ©ãƒ¼ã§ã‚‚æç”»ã‚’è©¦è¡Œ
                            this.showMXGraphError(drawioCode, mxError);
                        }
                    } else {
                        console.warn('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
                        // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å†èª­ã¿è¾¼ã¿ã‚’è©¦è¡Œ
                        this.loadMXGraphAndRetry(drawioCode);
                    }

                } catch (error) {
                    console.error('ãƒ•ãƒ­ãƒ¼å›³æ›´æ–°ã‚¨ãƒ©ãƒ¼:', error);
                    this.updateStatus('diagram', 'ã‚¨ãƒ©ãƒ¼');
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚è¡¨ç¤ºçŠ¶æ…‹ã«æˆ»ã™
                    this.elements.flowDiagram.classList.remove('svg-processing');
                    this.elements.flowDiagram.classList.add('svg-ready');
                }
            }
            
            // drawioã‚³ãƒ¼ãƒ‰ã‚’ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
            showDrawioAsText(drawioCode) {
                this.elements.flowDiagram.innerHTML = `
                    <div style="padding: 20px; font-family: monospace; font-size: 12px; overflow: auto; background: #f5f5f5; border-radius: 4px;">
                        <p style="margin-bottom: 10px; color: #666;">drawioã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚draw.ioã§é–‹ãã‹ã€ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</p>
                        <pre style="white-space: pre-wrap; word-wrap: break-word;">${this.escapeHtml(drawioCode)}</pre>
                    </div>
                `;
                
                requestAnimationFrame(() => {
                    this.elements.flowDiagram.classList.remove('svg-processing');
                    this.elements.flowDiagram.classList.add('svg-ready');
                });
                
                this.updateStatus('diagram', 'ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º');
            }

            // SVGè‡ªå‹•ãƒ•ã‚£ãƒƒãƒˆæ©Ÿèƒ½ï¼ˆãƒ•ãƒ«ã‚µã‚¤ã‚ºè¡¨ç¤ºï¼‰
            autoFitSVG(svgElement) {
                try {
                    const container = this.elements.flowDiagram;
                    const containerRect = container.getBoundingClientRect();
                    const containerWidth = containerRect.width - 20; // å°‘ã—ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
                    const containerHeight = containerRect.height - 20;
                    
                    console.log(`drawioãƒ•ãƒ«ã‚µã‚¤ã‚ºè¡¨ç¤º: container ${containerWidth}x${containerHeight}`);
                    
                    // viewBoxã‚’å…ˆã«è¨­å®šï¼ˆãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å‰ã«ï¼‰
                    if (!svgElement.getAttribute('viewBox')) {
                        const width = svgElement.getAttribute('width') || 800;
                        const height = svgElement.getAttribute('height') || 600;
                        svgElement.setAttribute('viewBox', `0 0 ${width} ${height}`);
                    }
                    
                    // preserveAspectRatioã‚’è¨­å®š
                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    // widthã¨heightå±æ€§ã‚’å‰Šé™¤ï¼ˆviewBoxã§åˆ¶å¾¡ï¼‰
                    svgElement.removeAttribute('width');
                    svgElement.removeAttribute('height');
                    
                    // CSSã§ã‚µã‚¤ã‚ºã‚’è¨­å®šï¼ˆä¸€åº¦ã«è¨­å®šï¼‰
                    Object.assign(svgElement.style, {
                        width: '100%',
                        height: '100%',
                        maxWidth: '100%',
                        maxHeight: '100%',
                        display: 'block',
                        margin: '0',
                        objectFit: 'contain'
                    });
                    
                } catch (error) {
                    console.error('drawioãƒ•ã‚£ãƒƒãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤º
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                }
            }

            // å¼·åˆ¶ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½
            forceScroll(element) {
                try {
                    // å³åº§ã«æœ€ä¸‹éƒ¨ã¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    element.scrollTop = element.scrollHeight;
                    
                    // å¿µã®ãŸã‚å†å®Ÿè¡Œ
                    setTimeout(() => {
                        element.scrollTop = element.scrollHeight;
                    }, 0);
                    
                    // ã•ã‚‰ã«å¿µã®ãŸã‚å†å®Ÿè¡Œ
                    setTimeout(() => {
                        element.scrollTop = element.scrollHeight;
                    }, 50);
                    
                } catch (error) {
                    console.warn('å¼·åˆ¶ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼:', error);
                }
            }

            // å¾“æ¥ã®è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½ï¼ˆäº’æ›æ€§ä¿æŒï¼‰
            autoScroll(element) {
                this.forceScroll(element);
            }

            finalizeGeneration(content) {
                console.log('ç”Ÿæˆå‡¦ç†æœ€çµ‚åŒ–');
                
                // å…¥åŠ›ä¸­ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ç¢ºå®Ÿã«éè¡¨ç¤º
                this.hideTypingIndicator();
                
                // æœ€çµ‚çš„ãªSVGæŠ½å‡º
                this.extractAndUpdateSVG(content);
                
                // drawioãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã®ã¿æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                const svgMatch = content.match(/<\?xml[\s\S]*?<\/mxfile>|<mxfile[\s\S]*?<\/mxfile>/);
                if (svgMatch) {
                    // å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                    this.showSuccess('ãƒ•ãƒ­ãƒ¼ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸï¼');
                }
                
                // ç”ŸæˆçŠ¶æ…‹ã‚’çµ‚äº†
                this.stopGenerating();
            }

            startGenerating() {
                console.log('ç”ŸæˆçŠ¶æ…‹é–‹å§‹');
                this.isGenerating = true;
                this.svgStarted = false; // SVGçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.accumulatedSvgCode = ''; // è“„ç©drawioã‚³ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.svgDisplayed = false; // drawioè¡¨ç¤ºçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                this.lastDisplayedSvgLength = 0; // è¡¨ç¤ºæ¸ˆã¿SVGé•·ã‚’ãƒªã‚»ãƒƒãƒˆ
                
                // ãƒ•ãƒ­ãƒ¼å›³ã‚¨ãƒªã‚¢ã‚’å®Œå…¨ã«ã‚¯ãƒªã‚¢ï¼ˆé‡è¦ï¼šä¸‹ã«è¿½åŠ ã•ã‚Œã‚‹ã®ã‚’é˜²ãï¼‰
                this.elements.flowDiagram.innerHTML = '';
                
                this.elements.generateBtn.disabled = true;
                this.elements.btnText.style.display = 'none';
                this.elements.btnSpinner.style.display = 'block';
                
                // ãƒ‘ãƒãƒ«ã®åˆæœŸåŒ–
                this.clearResults();
                this.updateStatus('chat', 'å‡¦ç†ä¸­');
            }

            stopGenerating() {
                console.log('ç”ŸæˆçŠ¶æ…‹çµ‚äº†');
                this.isGenerating = false;
                this.elements.btnText.style.display = 'block';
                this.elements.btnSpinner.style.display = 'none';
                this.updateStatus('chat', 'å®Œäº†');
                
                // ãƒœã‚¿ãƒ³çŠ¶æ…‹ã‚’æ­£ã—ãæ›´æ–°
                this.updateButtonState();
                
                if (this.currentStream) {
                    this.currentStream = null;
                }
            }

            // ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½ã®è¿½åŠ 
            addUserMessage(message) {
                if (!this.elements.chatMessages) {
                    console.error('chatMessagesè¦ç´ ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                const messageId = `msg-${this.messageIdCounter++}`;
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message user';
                messageDiv.setAttribute('data-message-id', messageId);
                messageDiv.innerHTML = `
                    <button class="prompt-info-btn" title="å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¡¨ç¤º">?</button>
                    <div class="message-content">${this.escapeHtml(message)}</div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                `;
                
                // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                const promptBtn = messageDiv.querySelector('.prompt-info-btn');
                promptBtn.addEventListener('click', () => {
                    this.showPromptModal(messageId);
                });
                
                this.elements.chatMessages.appendChild(messageDiv);
                this.forceScroll(this.elements.chatMessages);
                
                // ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã‚’ç¾åœ¨ã®ç”Ÿæˆã‚»ãƒƒã‚·ãƒ§ãƒ³ã«é–¢é€£ä»˜ã‘
                this.currentMessageId = messageId;
                
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã‚’ä¸€æ™‚çš„ã«ä¿å­˜ï¼ˆå¾Œã§å®Ÿéš›ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§æ›´æ–°ã•ã‚Œã‚‹ï¼‰
                this.promptHistory.set(messageId, {
                    userInput: message,
                    actualPrompt: null,
                    timestamp: new Date()
                });
            }

            updateAssistantMessage(content) {
                if (!this.elements.chatMessages) {
                    console.error('chatMessagesè¦ç´ ãŒå­˜åœ¨ã—ã¾ã›ã‚“');
                    return;
                }
                
                // æ—¢å­˜ã®ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›´æ–°ã¾ãŸã¯æ–°è¦ä½œæˆ
                let assistantMessage = this.elements.chatMessages.querySelector('.chat-message.assistant:last-child');
                
                if (!assistantMessage) {
                    assistantMessage = document.createElement('div');
                    assistantMessage.className = 'chat-message assistant';
                    this.elements.chatMessages.appendChild(assistantMessage);
                }

                // drawioã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ç½®ãæ›ãˆãŸå†…å®¹ã‚’å–å¾—
                const processedContent = this.replaceSvgWithReferenceMessage(content);
                
                assistantMessage.innerHTML = `
                    <div class="message-content">${processedContent}</div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                `;
                
                this.forceScroll(this.elements.chatMessages);
            }

            // drawioã‚³ãƒ¼ãƒ‰ã‚’å‚ç…§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ç½®ãæ›ãˆã‚‹é–¢æ•°ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å¯¾å¿œï¼‰
            replaceSvgWithReferenceMessage(content) {
                try {
                    console.log('replaceSvgWithReferenceMessage å‡¦ç†é–‹å§‹');
                    console.log('å…¥åŠ›ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é•·:', content.length);
                    
                    // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†ãŒå¿…è¦ã‹ãƒã‚§ãƒƒã‚¯
                    const needsEscape = content.includes('<') || content.includes('>');
                    
                    if (!needsEscape) {
                        // æ—¢ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ¸ˆã¿ã®å ´åˆï¼ˆãƒãƒƒãƒãƒ¢ãƒ¼ãƒ‰ï¼‰
                        console.log('æ—¢ã«ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ¸ˆã¿ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„');
                        return content;
                    }
                    
                    // drawioã‚³ãƒ¼ãƒ‰ã®é–‹å§‹ä½ç½®ã‚’æ¤œå‡º
                    const xmlStart = content.indexOf('<?xml');
                    const mxfileStart = content.indexOf('<mxfile');
                    
                    // drawioã‚³ãƒ¼ãƒ‰ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if (xmlStart !== -1 || mxfileStart !== -1) {
                        console.log('drawioã‚³ãƒ¼ãƒ‰æ¤œå‡ºï¼ˆå®Œå…¨ã¾ãŸã¯ä¸å®Œå…¨ï¼‰');
                        
                        // drawioã‚³ãƒ¼ãƒ‰ã®é–‹å§‹ä½ç½®ã‚’ç‰¹å®š
                        let svgStartIndex = -1;
                        if (xmlStart !== -1 && mxfileStart !== -1) {
                            svgStartIndex = Math.min(xmlStart, mxfileStart);
                        } else if (xmlStart !== -1) {
                            svgStartIndex = xmlStart;
                        } else {
                            svgStartIndex = mxfileStart;
                        }
                        
                        // drawioã‚³ãƒ¼ãƒ‰ã®å‰ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
                        const beforeSvg = content.substring(0, svgStartIndex);
                        console.log('drawioå‰ã®ãƒ†ã‚­ã‚¹ãƒˆ:', beforeSvg);
                        
                        // drawioã‚³ãƒ¼ãƒ‰ã®çµ‚äº†ä½ç½®ã‚’æ¤œå‡º
                        const mxfileEnd = content.indexOf('</mxfile>');
                        
                        let afterSvg = '';
                        let isComplete = false;
                        
                        if (mxfileEnd !== -1) {
                            // å®Œå…¨ãªdrawioã‚³ãƒ¼ãƒ‰ã®å ´åˆ
                            afterSvg = content.substring(mxfileEnd + 9); // '</mxfile>' ã®é•·ã•ã¯9
                            isComplete = true;
                            console.log('å®Œå…¨ãªdrawioã‚³ãƒ¼ãƒ‰æ¤œå‡º');
                        } else {
                            // ä¸å®Œå…¨ãªdrawioã‚³ãƒ¼ãƒ‰ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ï¼‰ã®å ´åˆ
                            afterSvg = ''; // SVGå¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã¯ã¾ã ãªã„
                            console.log('ä¸å®Œå…¨ãªdrawioã‚³ãƒ¼ãƒ‰æ¤œå‡ºï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ï¼‰');
                        }
                        
                        // å‚ç…§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ã‹ã©ã†ã‹ã§å¤‰ãˆã‚‹ï¼‰
                        const referenceMessage = isComplete ? 
                            `<div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin: 8px 0; border-left: 3px solid #1e40af;">
                                <strong>drawioã‚³ãƒ¼ãƒ‰</strong> ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸ<br>
                                è©³ç´°ã¯ä¸‹éƒ¨ã®ã€Œdrawioã‚³ãƒ¼ãƒ‰ã€ãƒ‘ãƒãƒ«ãŠã‚ˆã³å³å´ã®ã€Œãƒ•ãƒ­ãƒ¼å›³ã€ãƒ‘ãƒãƒ«ã§ã”ç¢ºèªãã ã•ã„
                            </div>` :
                            `<div style="background: #fefce8; padding: 10px; border-radius: 6px; margin: 8px 0; border-left: 3px solid #f59e0b;">
                                <strong>drawioã‚³ãƒ¼ãƒ‰</strong> ã‚’ç”Ÿæˆä¸­ã§ã™...<br>
                                è©³ç´°ã¯ä¸‹éƒ¨ã®ã€Œdrawioã‚³ãƒ¼ãƒ‰ã€ãƒ‘ãƒãƒ«ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«ç¢ºèªã§ãã¾ã™
                            </div>`;
                        
                        // å‰å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã—ã¦ã€å‚ç…§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨çµåˆ
                        const processedContent = 
                            this.escapeHtml(beforeSvg) + 
                            referenceMessage + 
                            this.escapeHtml(afterSvg);
                        
                        return processedContent;
                    }
                    // drawioã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆï¼ˆé€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆï¼‰
                    else {
                        console.log('drawioã‚³ãƒ¼ãƒ‰ãªã— - é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†');
                        return this.escapeHtml(content);
                    }
                    
                } catch (error) {
                    console.error('drawioç½®ãæ›ãˆã‚¨ãƒ©ãƒ¼:', error);
                    return this.escapeHtml(content);
                }
            }

            // drawioã‚³ãƒ¼ãƒ‰å‡ºåŠ›ä¸­ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆå‰Šé™¤äºˆå®š - äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
            isSvgCodeContent(content) {
                const hasSvgTags = content.includes('<mxfile') || content.includes('<?xml');
                if (hasSvgTags) {
                    const svgMatch = content.match(/<\?\s*xml[\s\S]*?<\/mxfile>|<mxfile[\s\S]*?<\/mxfile>/);
                    if (svgMatch) {
                        const svgLength = svgMatch[0].length;
                        const totalLength = content.length;
                        return (svgLength / totalLength) > 0.3; // é–¾å€¤ã‚’ä¸‹ã’ã¦ã€ã‚ˆã‚Šæ—©ãæ¤œå‡º
                    }
                }
                return false;
            }

            showTypingIndicator() {
                if (!this.elements.chatMessages) {
                    console.error('chatMessagesè¦ç´ ãŒå­˜åœ¨ã—ã¾ã›ã‚“ - ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼è¡¨ç¤ºä¸å¯');
                    return;
                }
                
                this.hideTypingIndicator(); // æ—¢å­˜ã®å‰Šé™¤
                
                const typingDiv = document.createElement('div');
                typingDiv.className = 'typing-indicator';
                typingDiv.id = 'typing-indicator';
                typingDiv.innerHTML = `
                    å…¥åŠ›ä¸­ 
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                `;
                this.elements.chatMessages.appendChild(typingDiv);
                this.forceScroll(this.elements.chatMessages);
            }

            hideTypingIndicator() {
                const typingIndicator = document.getElementById('typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }

            escapeHtml(text) {
                // HTMLã®å±é™ºãªæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
                let escaped = text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
                
                // æ”¹è¡Œã‚’<br>ã«å¤‰æ›
                escaped = escaped.replace(/\n/g, '<br>');
                
                // ç°¡å˜ãªãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³é¢¨ã®å¤‰æ›
                // ãƒªã‚¹ãƒˆé …ç›®ï¼ˆ- ã¾ãŸã¯ * ã§å§‹ã¾ã‚‹è¡Œï¼‰
                escaped = escaped.replace(/^([â€¢\-\*])\s+(.+)$/gm, '<li>$2</li>');
                escaped = escaped.replace(/(<li>.*<\/li>(\s*<br>)?)+/g, function(match) {
                    return '<ul style="margin: 8px 0; padding-left: 20px;">' + match.replace(/<br>/g, '') + '</ul>';
                });
                
                // ç•ªå·ä»˜ããƒªã‚¹ãƒˆï¼ˆæ•°å­—. ã§å§‹ã¾ã‚‹è¡Œï¼‰
                escaped = escaped.replace(/^(\d+)\.\s+(.+)$/gm, '<li>$2</li>');
                escaped = escaped.replace(/(<li>.*<\/li>(\s*<br>)?)+/g, function(match, offset, string) {
                    // å‰ã®æ–‡å­—ãŒ'>'ã§ãªã„å ´åˆã®ã¿ï¼ˆæ—¢ã«ulã§å›²ã¾ã‚Œã¦ã„ãªã„å ´åˆï¼‰
                    if (offset === 0 || string[offset - 1] !== '>') {
                        return '<ol style="margin: 8px 0; padding-left: 20px;">' + match.replace(/<br>/g, '') + '</ol>';
                    }
                    return match;
                });
                
                // å¤ªå­—ï¼ˆ**text**ï¼‰
                escaped = escaped.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                
                // ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆ`code`ï¼‰
                escaped = escaped.replace(/`([^`]+)`/g, '<code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px; font-family: monospace;">$1</code>');
                
                return escaped;
            }

            clearAll() {
                console.log('å…¨ã‚¯ãƒªã‚¢å®Ÿè¡Œ');
                
                this.elements.promptInput.value = '';
                this.clearResults();
                
                // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒªã‚»ãƒƒãƒˆ
                this.updateStatus('chat', 'å¾…æ©Ÿä¸­');
                this.updateStatus('code', 'å¾…æ©Ÿä¸­');
                this.updateStatus('diagram', 'å¾…æ©Ÿä¸­');
                
                // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›ã‚’ã‚¯ãƒªã‚¢ã—ãŸå¾Œã€æ‰‹å‹•ã§inputã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«
                this.elements.promptInput.dispatchEvent(new Event('input'));
            }

            // drawioã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
            async copySvgCode() {
                try {
                    // drawioã‚³ãƒ¼ãƒ‰è¦ç´ ã‹ã‚‰å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
                    const svgCodeElement = this.elements.svgCode;
                    
                    // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
                    if (svgCodeElement.classList.contains('placeholder')) {
                        console.log('drawioã‚³ãƒ¼ãƒ‰ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                        return;
                    }
                    
                    // HTMLã‚¿ã‚°ã‚’é™¤å»ã—ã¦ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®drawioã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
                    const svgCode = this.extractPlainSvgCode();
                    
                    if (!svgCode) {
                        console.log('drawioã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        return;
                    }
                    
                    // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
                    await navigator.clipboard.writeText(svgCode);
                    console.log('drawioã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                    
                    // ã‚³ãƒ”ãƒ¼æˆåŠŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                    this.showCopyFeedback();
                    
                } catch (error) {
                    console.error('ã‚³ãƒ”ãƒ¼ã‚¨ãƒ©ãƒ¼:', error);
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ç”¨
                    this.fallbackCopy();
                }
            }

            // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®drawioã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º
            extractPlainSvgCode() {
                console.log('extractPlainSvgCodeé–‹å§‹');
                console.log('accumulatedSvgCodeå­˜åœ¨ãƒã‚§ãƒƒã‚¯:', !!this.accumulatedSvgCode);
                console.log('accumulatedSvgCodeé•·ã•:', this.accumulatedSvgCode ? this.accumulatedSvgCode.length : 0);
                
                // ç¾åœ¨ä¿å­˜ã•ã‚Œã¦ã„ã‚‹drawioã‚³ãƒ¼ãƒ‰ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ï¼ˆæ¨å¥¨ï¼‰
                if (this.accumulatedSvgCode && (this.accumulatedSvgCode.includes('<?xml') || this.accumulatedSvgCode.includes('<mxfile'))) {
                    console.log('accumulatedSvgCodeã‹ã‚‰å–å¾— - æœ€åˆã®100æ–‡å­—:', this.accumulatedSvgCode.substring(0, 100));
                    return this.accumulatedSvgCode;
                }
                
                // ãªã‘ã‚Œã°è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰å–å¾—
                // innerHTMLã‹ã‚‰ç›´æ¥å–å¾—ã—ã¦ã€HTMLã‚¿ã‚°ã‚’é™¤å»
                let htmlContent = svgCodeElement.innerHTML;
                console.log('innerHTMLå–å¾— - æœ€åˆã®200æ–‡å­—:', htmlContent.substring(0, 200));
                
                // HTMLã‚¿ã‚°ã‚’é™¤å»ï¼ˆã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆã®spanã‚¿ã‚°ãªã©ï¼‰
                htmlContent = htmlContent.replace(/<span[^>]*>/g, '').replace(/<\/span>/g, '');
                console.log('spanã‚¿ã‚°é™¤å»å¾Œ - æœ€åˆã®200æ–‡å­—:', htmlContent.substring(0, 200));
                
                // HTMLã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆ&lt; â†’ < ãªã©ï¼‰
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                const textContent = tempDiv.textContent || tempDiv.innerText || '';
                console.log('HTMLãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œ - æœ€åˆã®200æ–‡å­—:', textContent.substring(0, 200));
                
                // drawioã‚³ãƒ¼ãƒ‰ã®é–‹å§‹ã¨çµ‚äº†ã‚’æ¢ã™
                const xmlStart = textContent.indexOf('<?xml');
                const mxfileStart = textContent.indexOf('<mxfile');
                const mxfileEnd = textContent.lastIndexOf('</mxfile>');
                
                console.log('æ¤œå‡ºä½ç½® - xmlStart:', xmlStart, 'mxfileStart:', mxfileStart, 'mxfileEnd:', mxfileEnd);
                
                // <?xml ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆ
                if (xmlStart !== -1 && mxfileEnd !== -1) {
                    const extracted = textContent.substring(xmlStart, mxfileEnd + 9);
                    console.log('xmlStartã‹ã‚‰æŠ½å‡º - æœ€åˆã®100æ–‡å­—:', extracted.substring(0, 100));
                    return extracted;
                }
                
                // <mxfile ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆï¼ˆXMLå®£è¨€ãŒãªã„å ´åˆï¼‰
                if (mxfileStart !== -1 && mxfileEnd !== -1) {
                    // XMLå®£è¨€ã‚’è¿½åŠ 
                    const mxfileContent = textContent.substring(mxfileStart, mxfileEnd + 9);
                    const withXmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>\n' + mxfileContent;
                    console.log('mxfileStartã‹ã‚‰æŠ½å‡ºï¼ˆXMLå®£è¨€è¿½åŠ ï¼‰ - æœ€åˆã®100æ–‡å­—:', withXmlDeclaration.substring(0, 100));
                    return withXmlDeclaration;
                }
                
                console.log('drawioã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ');
                return null;
            }

            // ã‚³ãƒ”ãƒ¼æˆåŠŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤º
            showCopyFeedback() {
                const copyBtn = this.elements.copySvgBtn;
                const tooltip = copyBtn.querySelector('.copy-tooltip');
                const btnText = copyBtn.querySelector('span');
                const btnIcon = copyBtn.querySelector('i');
                
                // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’å¤‰æ›´
                copyBtn.classList.add('copied');
                btnText.textContent = 'ã‚³ãƒ”ãƒ¼æ¸ˆã¿';
                btnIcon.className = 'fas fa-check';
                
                // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—è¡¨ç¤º
                tooltip.classList.add('show');
                
                // 2ç§’å¾Œã«å…ƒã«æˆ»ã™
                setTimeout(() => {
                    copyBtn.classList.remove('copied');
                    btnText.textContent = 'ã‚³ãƒ”ãƒ¼';
                    btnIcon.className = 'fas fa-copy';
                    tooltip.classList.remove('show');
                }, 2000);
            }

            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚³ãƒ”ãƒ¼ï¼ˆå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶ç”¨ï¼‰
            fallbackCopy() {
                const svgCode = this.extractPlainSvgCode();
                if (!svgCode) return;
                
                // ä¸€æ™‚çš„ãªãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚’ä½œæˆ
                const textarea = document.createElement('textarea');
                textarea.value = svgCode;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                
                // é¸æŠã—ã¦ã‚³ãƒ”ãƒ¼
                textarea.select();
                try {
                    document.execCommand('copy');
                    console.log('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: drawioã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
                    this.showCopyFeedback();
                } catch (err) {
                    console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚³ãƒ”ãƒ¼ã‚‚å¤±æ•—:', err);
                }
                
                // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚’å‰Šé™¤
                document.body.removeChild(textarea);
            }

            // drawioãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            async downloadSvgFile() {
                try {
                    // drawioã‚³ãƒ¼ãƒ‰è¦ç´ ã‹ã‚‰å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
                    const svgCodeElement = this.elements.svgCode;
                    
                    // ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
                    if (svgCodeElement.classList.contains('placeholder')) {
                        console.log('drawioã‚³ãƒ¼ãƒ‰ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“');
                        return;
                    }
                    
                    // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®drawioã‚³ãƒ¼ãƒ‰ã‚’å–å¾—
                    const svgCode = this.extractPlainSvgCode();
                    
                    if (!svgCode) {
                        console.log('drawioã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
                        return;
                    }
                    
                    // Blobã‚’ä½œæˆ
                    const blob = new Blob([svgCode], { type: 'application/xml;charset=utf-8' });
                    
                    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
                    const downloadLink = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    
                    // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆï¼ˆæ—¥ä»˜ã¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å«ã‚€ï¼‰
                    const now = new Date();
                    const timestamp = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const filename = `business-flow-${timestamp}.drawio`;
                    
                    downloadLink.href = url;
                    downloadLink.download = filename;
                    
                    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºç«ã•ã›ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    // URLã‚’è§£æ”¾
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    console.log(`drawioãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸ: ${filename}`);
                    
                    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æˆåŠŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                    this.showDownloadFeedback();
                    
                } catch (error) {
                    console.error('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼:', error);
                    this.showError('ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            }

            // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æˆåŠŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤º
            showDownloadFeedback() {
                const tooltip = document.querySelector('.download-tooltip');
                if (tooltip) {
                    // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ã‚’è¡¨ç¤º
                    tooltip.style.opacity = '1';
                    tooltip.style.transform = 'translateX(-50%) translateY(0)';
                    
                    // 2ç§’å¾Œã«éè¡¨ç¤º
                    setTimeout(() => {
                        tooltip.style.opacity = '0';
                        tooltip.style.transform = 'translateX(-50%) translateY(10px)';
                    }, 2000);
                }
            }

            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºç”¨ã«é€£ç¶šã™ã‚‹ç©ºè¡Œã‚’å‰Šæ¸›
            cleanupPromptDisplay(prompt) {
                // é€£ç¶šã™ã‚‹ç©ºè¡Œã‚’å˜ä¸€ã®ç©ºè¡Œã«ç½®æ›
                let cleaned = prompt
                    // 3è¡Œä»¥ä¸Šã®é€£ç¶šã™ã‚‹æ”¹è¡Œã‚’2è¡Œã«
                    .replace(/\n{3,}/g, '\n\n')
                    // è¡Œé ­ã®é€£ç¶šã™ã‚‹ãƒã‚¤ãƒ•ãƒ³ã‚„ã‚¤ã‚³ãƒ¼ãƒ«ï¼ˆåŒºåˆ‡ã‚Šç·šï¼‰ã‚’çŸ­ç¸®
                    .replace(/^[-=]{40,}$/gm, '--------')
                    // è¡Œé ­ã®é€£ç¶šã™ã‚‹ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ï¼ˆåŒºåˆ‡ã‚Šç·šï¼‰ã‚’çŸ­ç¸®
                    .replace(/^[_â”]{40,}$/gm, '--------')
                    // # ---------------------------------------- ã®ã‚ˆã†ãªåŒºåˆ‡ã‚Šã‚’ç°¡ç•¥åŒ–
                    .replace(/^#\s*[-=]+\s*$/gm, '#--------')
                    // ç©ºç™½ã ã‘ã®è¡Œã‚’å‰Šé™¤
                    .replace(/^\s+$/gm, '');
                
                return cleaned;
            }

            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
            showPromptModal(messageId) {
                const promptData = this.promptHistory.get(messageId);
                if (!promptData) {
                    console.error('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“:', messageId);
                    return;
                }
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ§‹ç¯‰
                let modalContent = `
                    <div class="prompt-section">
                        <div class="prompt-section-title">ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›</div>
                        <div class="prompt-content">${this.escapeHtml(promptData.userInput)}</div>
                    </div>
                `;
                
                if (promptData.actualPrompt) {
                    // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‹ã‚‰é€£ç¶šã™ã‚‹ç©ºè¡Œã‚’å‰Šæ¸›
                    const cleanedPrompt = this.cleanupPromptDisplay(promptData.actualPrompt);
                    
                    modalContent += `
                        <div class="prompt-section">
                            <div class="prompt-section-title">å®Ÿéš›ã«é€ä¿¡ã•ã‚ŒãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</div>
                            <div class="prompt-content">${this.escapeHtml(cleanedPrompt)}</div>
                            <button class="prompt-copy-btn" onclick="window.biTflowDemo.copyPrompt('${messageId}')">
                                <i class="fas fa-copy"></i>
                                <span>ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚³ãƒ”ãƒ¼</span>
                            </button>
                        </div>
                    `;
                } else {
                    modalContent += `
                        <div class="prompt-section">
                            <div class="prompt-section-title">å®Ÿéš›ã«é€ä¿¡ã•ã‚ŒãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ</div>
                            <div class="prompt-content" style="color: #9ca3af; font-style: italic;">
                                ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ã¯ã¾ã å–å¾—ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
                                ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®å¿œç­”ã‚’å¾…ã£ã¦ã„ã¾ã™...
                            </div>
                        </div>
                    `;
                }
                
                modalContent += `
                    <div class="prompt-section">
                        <div class="prompt-section-title">é€ä¿¡æ™‚åˆ»</div>
                        <div class="prompt-content">${promptData.timestamp.toLocaleString()}</div>
                    </div>
                `;
                
                this.elements.promptModalBody.innerHTML = modalContent;
                this.elements.promptModal.classList.add('show');
            }
            
            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
            closePromptModal() {
                this.elements.promptModal.classList.remove('show');
            }
            
            // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
            async copyPrompt(messageId) {
                const promptData = this.promptHistory.get(messageId);
                if (!promptData || !promptData.actualPrompt) {
                    console.error('ã‚³ãƒ”ãƒ¼ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                try {
                    await navigator.clipboard.writeText(promptData.actualPrompt);
                    
                    // ã‚³ãƒ”ãƒ¼æˆåŠŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                    const copyBtn = this.elements.promptModalBody.querySelector('.prompt-copy-btn');
                    if (copyBtn) {
                        copyBtn.classList.add('copied');
                        const span = copyBtn.querySelector('span');
                        const originalText = span.textContent;
                        span.textContent = 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼';
                        
                        setTimeout(() => {
                            copyBtn.classList.remove('copied');
                            span.textContent = originalText;
                        }, 2000);
                    }
                } catch (error) {
                    console.error('ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—:', error);
                }
            }

            clearResults() {
                // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯å±¥æ­´ã‚’ä¿æŒï¼ˆã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ä¿æŒã‹ã‚‰å…¨å±¥æ­´ä¿æŒã«å¤‰æ›´ï¼‰
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ä¿æŒã—ã€æ–°ã—ã„ä¼šè©±ã‚’ç¶™ç¶šã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
                
                // drawioã‚³ãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢
                this.accumulatedSvgCode = '';
                this.elements.svgCode.innerHTML = 'ç”Ÿæˆã•ã‚ŒãŸdrawioã‚³ãƒ¼ãƒ‰ãŒã“ã“ã«æ®µéšçš„ã«è¡¨ç¤ºã•ã‚Œã¾ã™...';
                this.elements.svgCode.classList.add('placeholder');
                
                // ãƒ•ãƒ­ãƒ¼å›³ã‚’ã‚¯ãƒªã‚¢ï¼ˆè¡¨ç¤ºçŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆï¼‰
                this.elements.flowDiagram.classList.remove('svg-processing', 'svg-ready');
                this.elements.flowDiagram.innerHTML = '<div class="placeholder">ç”Ÿæˆã•ã‚ŒãŸæ¥­å‹™ãƒ•ãƒ­ãƒ¼å›³ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>';
                
                // ã‚¿ã‚¤ãƒãƒ¼ã¨ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                if (this.updateTimer) {
                    clearTimeout(this.updateTimer);
                    this.updateTimer = null;
                }
                this.svgDisplayed = false;
                this.lastDisplayedSvgLength = 0;
            }

            showError(message) {
                if (!this.elements.chatMessages) {
                    console.error('chatMessagesè¦ç´ ãŒå­˜åœ¨ã—ã¾ã›ã‚“ - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:', message);
                    return;
                }
                
                const errorMessage = document.createElement('div');
                errorMessage.className = 'chat-message system';
                errorMessage.innerHTML = `
                    <div class="message-content">ã‚¨ãƒ©ãƒ¼: ${this.escapeHtml(message)}</div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                `;
                this.elements.chatMessages.appendChild(errorMessage);
                this.forceScroll(this.elements.chatMessages);
                
                console.error('ã‚¨ãƒ©ãƒ¼è¡¨ç¤º:', message);
            }

            showSuccess(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'completion-notification';
                successDiv.innerHTML = `
                    <div class="completion-content">
                        <div class="completion-icon">
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M20 6L9 17L4 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                        <div class="completion-text">
                            <div class="completion-title">${message}</div>
                            <div class="completion-subtitle">æ¥­å‹™ãƒ•ãƒ­ãƒ¼å›³ã®ç”ŸæˆãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ</div>
                        </div>
                    </div>
                `;
                
                // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ 
                const style = document.createElement('style');
                style.textContent = `
                    .completion-notification {
                        position: fixed;
                        bottom: 24px;
                        right: 24px;
                        transform: translateX(400px);
                        background: #1a1a1a;
                        border-radius: 12px;
                        padding: 16px 20px;
                        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                        z-index: 10000;
                        opacity: 0;
                        transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        max-width: 320px;
                    }
                    
                    .completion-notification.show {
                        opacity: 1;
                        transform: translateX(0);
                    }
                    
                    .completion-notification.hide {
                        opacity: 0;
                        transform: translateX(400px);
                    }
                    
                    .completion-content {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                    }
                    
                    .completion-icon {
                        width: 32px;
                        height: 32px;
                        background: #10b981;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        flex-shrink: 0;
                    }
                    
                    .completion-icon svg {
                        width: 18px;
                        height: 18px;
                        stroke-width: 3;
                    }
                    
                    .completion-text {
                        display: flex;
                        flex-direction: column;
                        gap: 2px;
                    }
                    
                    .completion-title {
                        font-size: 15px;
                        font-weight: 500;
                        color: #ffffff;
                        margin-bottom: 2px;
                    }
                    
                    .completion-subtitle {
                        font-size: 13px;
                        color: #9ca3af;
                        line-height: 1.4;
                    }
                    
                    @media (max-width: 640px) {
                        .completion-notification {
                            bottom: 16px;
                            right: 16px;
                            left: 16px;
                            max-width: none;
                        }
                    }
                `;
                
                if (!document.querySelector('#completion-notification-styles')) {
                    style.id = 'completion-notification-styles';
                    document.head.appendChild(style);
                }
                
                // è¡¨ç¤º
                document.body.appendChild(successDiv);
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                requestAnimationFrame(() => {
                    successDiv.classList.add('show');
                });
                
                // è‡ªå‹•çš„ã«æ¶ˆã™
                setTimeout(() => {
                    successDiv.classList.remove('show');
                    successDiv.classList.add('hide');
                    
                    setTimeout(() => {
                        if (successDiv.parentNode) {
                            successDiv.parentNode.removeChild(successDiv);
                        }
                    }, 300);
                }, 3500);
                
                console.log('æˆåŠŸè¡¨ç¤º:', message);
            }
        }

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†æ™‚ã«ãƒ‡ãƒ¢ã‚’åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMèª­ã¿è¾¼ã¿å®Œäº† - BiT-Flow ãƒ—ãƒ­ã‚­ã‚·ãƒ‡ãƒ¢åˆæœŸåŒ–é–‹å§‹');
            
            // MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®çŠ¶æ…‹ã‚’ç¢ºèª
            if (typeof mxGraph === 'undefined') {
                console.warn('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å†è©¦è¡Œã—ã¾ã™...');
                
                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œ
                setTimeout(() => {
                    if (typeof mxGraph !== 'undefined') {
                        console.log('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã‚’ç¢ºèª');
                        initializeDemo();
                    } else {
                        console.error('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
                        // ãã‚Œã§ã‚‚åˆæœŸåŒ–ã‚’è©¦è¡Œ
                        initializeDemo();
                    }
                }, 1000);
            } else {
                console.log('MXGraphãƒ©ã‚¤ãƒ–ãƒ©ãƒª: åˆ©ç”¨å¯èƒ½');
                initializeDemo();
            }
            
            function initializeDemo() {
                try {
                    window.biTflowDemo = new BiTFlowProxyDemo();
                    console.log('BiT-Flow ãƒ—ãƒ­ã‚­ã‚·ãƒ‡ãƒ¢åˆæœŸåŒ–æˆåŠŸ');
                    
                    // MXGraphã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã‚’å‡ºåŠ›
                    if (typeof mxClient !== 'undefined') {
                        console.log('MXGraphãƒãƒ¼ã‚¸ãƒ§ãƒ³:', mxClient.VERSION);
                    }
                } catch (error) {
                    console.error('BiT-Flow ãƒ—ãƒ­ã‚­ã‚·ãƒ‡ãƒ¢åˆæœŸåŒ–å¤±æ•—:', error);
                }
            }
        });

        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        window.addEventListener('error', function(event) {
            console.error('ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼:', event.error);
        });

        window.addEventListener('unhandledrejection', function(event) {
            console.error('æœªå‡¦ç†Promiseæ‹’å¦:', event.reason);
        });
    </script>
</body>
</html>